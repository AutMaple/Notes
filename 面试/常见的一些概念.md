## 什么是 ASM

ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。**ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。**

ASM 能够通过改造既有类，直接生成需要的代码。**增强的代码是硬编码在新生成的类文件内部的，没有反射带来性能上的付出**。同时，ASM 与 Proxy 编程不同，不需要为增强代码而新定义一个接口，生成的代码可以覆盖原来的类，或者是原始类的子类。**它是一个普通的 Java 类而不是 proxy 类**，甚至可以在应用程序的类框架中拥有自己的位置，派生自己的子类。

相比于其他流行的 Java 字节码操纵工具，ASM 更小更快。ASM 具有类似于 BCEL 或者 SERP 的功能，而只有 33k 大小，而后者分别有 350k 和 150k。同时，同样类转换的负载，如果 ASM 是 60% 的话，BCEL 需要 700%，而 SERP 需要 1100% 或者更多。

## 什么是 RPC

RPC 称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。 通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。 所以，RPC的作用主要体现在这两个方面：

- 屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；
- 隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。

### RPC 框架基本架构

下面我们通过一幅图来说说 RPC 框架的基本架构 ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3233fd8e9914fdcab290794e7a0f0c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.jpg) RPC 框架包含三个最重要的组件，分别是客户端、服务端和注册中心。在一次 RPC 调用流程中，这三个组件是这样交互的：

- 服务端在启动后，会将它提供的服务列表发布到注册中心，客户端向注册中心订阅服务地址；
- 客户端会通过本地代理模块 Proxy 调用服务端，Proxy 模块负责将方法、参数等数据转化成网络字节流；
- 客户端从服务列表中选取其中一个的服务地址，并将数据通过网络发送给服务端；
- 服务端接收到数据后进行解码，得到请求信息；
- 服务端根据解码后的请求信息调用对应的服务，然后将调用结果返回给客户端。

### RPC 框架通信流程以及涉及到的角色

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7c83315d4d247a1aed076e481fe0e11~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.jpg) 
从上面这张图中，可以看见 RPC 框架一般有这些组件：服务治理(注册发现)、负载均衡、容错、序列化/反序列化、编解码、网络传输、线程池、动态代理等角色，当然有的RPC框架还会有连接池、日志、安全等角色。

## CAS 是什么

CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，是一种无锁原子算法，映射到操作系统就是一条 CPU 的原子指令，其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，在 intel 的CPU中，使用的是 cmpxchg 指令，就是说 CAS 是靠硬件实现的，从而在硬件层面提升效率。Java 并发包中的很多类都使用了 CAS 技术

CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。

CAS 指令执行时，当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B，否则就表示当前 V 里面的值被其他线程修改了，就什么都不做。CAS 的返回值为 V 里面存储的真实值。整个比较并替换的操作是一个原子操作。

当多个线程同时使用 CAS 操作一个变量时，最多只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试（自旋），当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以避免其他线程对当前线程的干扰。

与锁相比，使用CAS会使程序看起来更加复杂一些，但是使用无锁的方式完全没有锁竞争带来的线程间频繁调度的开销和阻塞，它对死锁问题天生免疫，因此他要比基于锁的方式拥有更优越的性能。

简单的说，CAS 需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，说明它已经被别人修改过了。你就需要重新读取，再次尝试修改就好了。

### CAS的缺点

CAS虽然很高效的解决了原子操作问题，但是 CAS 仍然存在三大问题。

1. 循环时间长开销很大(循环等待/自旋时间太长)。
2. 只能保证一个共享变量的原子操作。
3. ABA 问题。

**循环时间长开销很大：**我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。

**只能保证一个共享变量的原子操作：**当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。

#### 什么是 ABA 问题？ABA 问题怎么解决？

CAS 的使用流程通常如下：1）首先从地址 V 读取值 A；2）根据 A 计算目标值 B；3）通过 CAS 以原子的方式将地址 V 中的值从 A 修改为 B。

但是在第 1 步中读取的值是 A，并且在第 3 步修改成功了，我们就能说它的值在第 1 步和第 3 步之间没有被其他线程改变过了吗？

如果在这段期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的 “ABA” 问题。Java 并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性,对于 ABA 问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加 1，即A —> B —> A，变成 1A —> 2B —> 3A，采用 AtomicStampedRdference 类可以实现这个方案。因此，在使用 CAS 前要考虑清楚 “ABA” 问题是否会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

### 参考链接

- [搞定CAS的原理，看这一篇就够了！](https://blog.csdn.net/qq_42370146/article/details/105559575)

- [面试必问的CAS，你懂了吗？](https://zhuanlan.zhihu.com/p/34556594)



