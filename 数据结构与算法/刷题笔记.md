# 刷题笔记

- TopK 问题要重视，很经典

## 递归

编写递归代码需要注意的点：

1. 递归总有最简单的情况，因此递归代码的第一条语句总是一个包含着 return 的条件语句
2. 递归调用总是去尝试解决一个规模更小的问题，这样递归才能够收敛到最简单的情况
3. 递归调用尝试解决的子问题中不应该存在交集，即一个递归函数中，有两个子递归调用，那么这两个子递归调用处理的问题不应该存在交集

违背上述的任意一条都有可能得到错误的结果或者是低效的代码。而坚持这些原则能够写出清晰、正确且容易评估性能的程序

使用递归的另外一个原因是我们可以使用数学模型来估计程序的性能



再使用递归的过程中，如果想要将某一个结果返回需要做的就是：在递归体中规定好所有可能返回的情况，最后将递归方法放在最后的 return 语句中，因为递归的**终止条件**就是放在 return 语句中的，例如：

这道题的作用就是返回平衡二叉树中值为 val 的节点

```java
 public TreeNode searchBST(TreeNode root, int val){
    if(root == null)
        return null;
    if(root.val == val)
        return root;
    return searchBST(val < root.val ? root.left : root.right, val);
}
```



## 查找

### 二分查找法

```java
// 返回 Val 插入的位置
public int binarySearch(int val){
    // 数组的值按照从大到小的顺序进行排列
    int low = 0;
    int high = this.nums.size();
    while(low <= high){
        int mid = (low + high) / 2;
        int midVal = this.nums.get(mid);
        if(midVal > val)
            low = mid + 1;
        else if(midVal < val)
            high = mid - 1;
        else
            return low;
    }
    return low;
}
```

### 快速排序法

```java
public void quickSort(int[] arr, int low, int high){
    if(low >= high)
        return;
    int start = low;
    int end = high;
    int refVal = arr[low];
    while(low < high){
        // 这个 while 循环是从后往前还是从前往后，取决于 refVal 的值
        // 如果 refVal 的值是数组中第一个值，则得从后往前开始
        // 如果 refVal 的值是数组中最后一个值，则得从前往后开始
        // 因为 refVal 存储数组中的值后，对数组对应的位置进行赋值操作时，就不会出现覆盖的情况
        while(low < high && arr[high] >= ref)
            high--;
        arr[low] = arr[high];
        while(low < high && arr[low] <= ref)
            low++;
        arr[high] = arr[low];
    }
    arr[low] = refVal;
	quickSort(arr, start, low - 1);
    quickSort(alow+1, end);
}
```



