# Shell 入门

## 快速使用

在编写 shell 脚本的时候，需要在脚本的第一行加上如下语句

```bash
#!/bin/bash
```

其中的 `#!` 是一种约定，该标记告诉系统，该脚本该使用何种解释器来执行

在文件中输入如下代码

```bash
#!/bin/bash

echo "Hello Shell"
```

执行该脚本将在命令行中输出：`Hello Shell`

## 变量

### 创建变量

声明一个变量和 python 声明变量是一样的，要使用变量时，直接写变量名并进行赋值，例如

```bash
username="AutMaple"
password="111111"
```

其中需要注意的就是，等号的两边不能够有空格

#### 只读型变量

如果想创建一个不能够修改的变量，可以在变量名前使用 `readonly` 关键字进行声明,例如

```bash
readonly username="AutMaple"
# username="111111"
```

此时如果试图去修改变量 `username` 的值，会出现如下的错误信息

```txt
username：只读变量
```

### 删除变量

如果要删除一个变量，可以使用 `unset` 关键字, 例如

```bash
unset password
```

### 使用变量

要在其他的地方使用声明过的变量时，可以使用 `$+变量名` 的方式使用对应的变量，
在使用变量时，对应的变量名可以使用 `{}` 进行包裹，也可以不使用 `{}` 进行包裹，
建议对全部变量的使用都是 `{}` 包裹起来

```bash
username="AutMaple"
echo "Hello ${username}"
```

执行上述语句，将会在终端中输出 `Hello AutMaple`

### 变量类型

运行 shell 时，会存在三种类型的变量

- 局部变量 ==> 只在当前 shell 中有效，其他的 shell 启动的程序无法访问局部变量

- 环境变量 ==> 所有的 shell 程序都可以访问的变量

- 系统变量 ==> 该变量是由 shell 程序设置的变量，这些变量中，有的是环境变量，
有的是局部变量，这些变量的设置，都是用于保证 shell 程序的正常运行

#### 常用的系统变量

| 变量名 |                             含义                             |
| :----: | :----------------------------------------------------------: |
|   $n   | 表示传递给脚本的第 n 个参数, $1 表示传递的第 1 个参数，$2 表示传递的第二个参数 |
|   $#   |                        脚本的参数个数                        |
|   $*   | 以"参数1 参数2 参数3"的形式返回所有参数的值，将所有的参数放在一个字符串中 |
|   $@   | 以"参数" "参数2" "参数3"... 的形式返回参数的值，将每一个参数封装成一个单独的字符串 |
|   $0   |                         脚本的文件名                         |
|   $?   |                      上一条命令的返回值                      |
|   $$   |                      返回本进程的进程号                      |

## 字符串

字符串不管在任何语言中，都是非常重要的存在

在 shell 脚本中，字符串有两种形式，一种是用双引号 `""` 包裹起来的字符串,
另一种是用但引号 `''` 包裹起来的字符串，例如

```bash
username="AutMaple"
username2='AUtMaple609'
```
这两种方式声明的字符串变量都是可行的，那么这两种不同形式的字符串有什么区别呢？

### 单引号和双引号的区别

1. 单引号中的任何字符都会进行原样的输出，在单引号字符串中使用变量,
shell 程序并不会将字符串对应的值进行替换

2. 单引号字串中不能出现单独一个的单引号(对单引号使用转义符后也不行)，
但可成对出现，作为字符串拼接使用

3. 双引号中可以有变量，也可以存在转义字符

例如

```bash
#!/bin/sh

username="AutMaple"
str1='111 ${username}'
str2='111 '${username}''
str3="111 ${username}"


echo ${str1}
echo ${str2}
echo ${str3}
```

上述代码的输出如下

```txt
111 ${username}
111 AutMaple
111 AutMaple
```

### 获取字符串的长度

获取字符串长度可以使用 `${#变量名}` 的方式获取字符串的长度

```bash
username="AutMaple"
echo ${#username}
```

执行代码之后输出为 `8`

### 截取字符串

要获取字符串的某一部分可以使用 `${varName:start:count}` 来截取字符串, 例如

```bash
username="AutMaple"
echo ${username:0:3}
```

执行结果：Aut

## 数组

bash 中只支持定义一维数组，定义数组的方式：

```bash
arrName=(val1 val2 val3 val4)
```

可以使用 `${arrName[index]}` 的方式访问数组中下标为 index 的元素

### 获取数组的长度

可以使用如下方式获取数组的长度

```bash
length1=${#arrName[@]}
length2=${#arrName[*]}
```

例子：

```bash
arr=("Hello" "World1")

echo ${#arr[@]} # 2
echo ${#arr[*]} # 2
```

### 获取某个元素的长度

```bash
length=${#arrName[n]}
```

例子：

```bash
arr=("Hello" "World1")

echo ${#arr[0]} # 5
echo ${#arr[1]} # 6
```

## 获取数组中的所有元素

获取数组中的所有元素有两种方式

- `${arrName[*]}` ==> 将数组中的所有元素封装在一个字符串中并返回，适合一次性打印
- `${arrName[@]}` ==> 将数组中的每一个元素单独的放在字符串中，并进行返回

## 注释

### 单行注释

shell 中的单行注释以 `#`开头

```bash
# 这是注释内容不会被执行
```

### 多行注释

shell 中的多行注释的语法如下：

```bash
:<<EOF
注释内容
...
...
...
EOF
```

```bash
:<<EOF
这里面的是注释的内容，不会被代码所执行
这里面的是注释的内容，不会被代码所执行
这里面的是注释的内容，不会被代码所执行
这里面的是注释的内容，不会被代码所执行
这里面的是注释的内容，不会被代码所执行
这里面的是注释的内容，不会被代码所执行
EOF
```

## 参数

在执行 shell 脚本时，可以向脚本传递参数。传递参数的方式是在命令行中将参数跟在 shell 脚本的后面，传递多个参数时，以空格隔开，例如

```bash
$ ./test.sh 3 4
```

### 取参数

取参数通过 `${n}` 的方式取出传递的每一个参数，参数从 `0` 开始编号，第 0 个元素表示的是执行的 shell 脚本的文件名，1 ~ n 则是传递给 shell 脚本的参数

```bash
echo "${0} ${1} ${2}"

# 输出：./test.sh 3 4
```

### 传递参数时，常用的系统变量

| 变量名 |                             含义                             |
| :----: | :----------------------------------------------------------: |
|   $#   |                        脚本的参数个数                        |
|   $*   | 以 "参数1 参数2 参数3" 的形式返回所有参数的值，将所有的参数放在一个字符串中 |
|   $@   | 以 "参数" "参数2" "参数3"... 的形式返回参数的值，将每一个参数封装在一个单独的字符串中 |
|   $0   |                         脚本的文件名                         |

## 运算符

原生的 bash 并不支持简单的数学运算，但可以使用其他的命令来实现，例如 `awk` 和 `expr`。其中 `expr` 最为常用，例如

```bash
val=`expr 1 + 3`
echo ${val} # 输出：4
```

注意：

- 在 shell 脚本中，使用 `expr` 命令时，需要使用 ” ` “ 反引号将表达式包裹起来，这个反引号的作用就是将反引号中命令执行的结果返回给对应的变量
- 运算符的两边需要有空格，不然是不对的，如 `1+3`这是错误，执行该命令时，将不会得到 结果`4`，而是会得到结果`1+3`

### 运算符

### 算术运算符

| 运算符 | 说明                                          |
| :----- | :-------------------------------------------- |
| +      | 加法                                          |
| -      | 减法                                          |
| *      | 乘法                                          |
| /      | 除法                                          |
| %      | 取余                                          |
| =      | 赋值                                          |
| ==     | 相等。用于比较两个数字，相同则返回 true。     |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 |

使用示例

```bash
a=10
b=3

echo `expr $a + $b`  # 输出：13
echo `expr $a - $b`  # 输出：7
echo `expr $a \* $b` # 输出：20
echo `expr $a / $b`  # 输出：3
echo `expr $a % $b`  # 输出：1
```

**注意**

`*` 乘法运算符，不能够直接使用符号 `*` 而是需要进行转义`\*`

### 比较运算符

| 运算符 | 说明                                                  | 举例          |
| :----- | :---------------------------------------------------- | :------------ |
| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] |

使用示例

```bash
a=10
b=20

if [ $a -eq $b ]
then 
    echo "a == b"
else
    ehco "a != b"
fi
if [ $a -ne $b ]
then
    echo "a != b"
else
    echo "a == b"
fi
if [ $a -gt $b ]
then
    echo "a > b"
else
    echo "a <= b"
fi
if [ $a -lt $b ]
then 
    echo "a < b"
else
    echo "a >= b"
fi
if [ $a -ge $b ]
then
    echo "a >= b"
else
    echo "a < b"
fi
if [ $a -le $b ]
then
    echo "a <= b"
else
    echo "a > b"
fi
```

输出：

```text
a != b
a != b
a <= b
a < b
a < b
a <= b
```

### 布尔运算符

| 运算符 | 说明                                                | 举例                        |
| :----- | :-------------------------------------------------- | :-------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。     |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] |

### 逻辑运算符

| 运算符 | 说明       | 举例                                       |
| :----- | :--------- | :----------------------------------------- |
| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |
| \|\|   | 逻辑的 OR  | [[ $a -lt 100 \|\| $b -gt 100 ]] 返回 true |

### 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                     |
| :----- | :------------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | [ $a ] 返回 true。       |

## 文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

属性检测描述如下：

| 操作符  | 说明                                                         | 举例                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |

其他检查符：

- **-S**: 判断某文件是否 socket。
- **-L**: 检测文件是否存在并且是一个符号链接。
