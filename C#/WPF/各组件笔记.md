相信的 Property 介绍可以在 [官网](https://docs.microsoft.com/en-us/dotnet/api/system.windows?view=windowsdesktop-6.0) 进行查看，进入官网后，直接搜索对应的属性即可

# 自定义组件样式

可以创建一个资源文件: MenuButtonTheme.xaml 文件，如

```xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
   
     <!-- BaseOn 属性类似于继承-->
     <!-- 如果只指定了 TargetType 而没有指定 Key 值的话，那么系统会自动的给所有的 RadioButton 设置声明的样式-->
    <Style BasedOn="{StaticResource {x:Type ToggleButton}}"
           TargetType="RadioButton" 
           x:Key="MenuButtonTheme">
        <Style.Setters>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="RadioButton">
                        <Grid VerticalAlignment="Stretch"
                              HorizontalAlignment="Stretch"
                              Background="{TemplateBinding Background}">
                            <TextBlock Text="{TemplateBinding Content}"
                                       VerticalAlignment="Center"
                                       Margin="50,0,0,0"/>

                        </Grid>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>

            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="BorderThickness" Value="0"/>
        </Style.Setters>

        <Style.Triggers>
            <Trigger Property="IsChecked" Value="True">
                <Setter Property="Background" Value="#22202f"/>
            </Trigger>
        </Style.Triggers>
    </Style>
</ResourceDictionary>
```

如果要使用，需要在 App.xaml 文件中进行注册

```xaml
<Application x:Class="WPFLocalization.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:WPFLocalization"
             xmlns:viewModel="clr-namespace:WPFLocalization.MVVM.ModelAndView"
             xmlns:view="clr-namespace:WPFLocalization.MVVM.Views"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Themes/MenuButtonTheme.xaml"/>
                <ResourceDictionary Source="Themes/TextBoxTheme.xaml"/>
            </ResourceDictionary.MergedDictionaries>

            <DataTemplate DataType="{x:Type viewModel:HomeViewModel}">
                <view:HomeView/>
            </DataTemplate>
            <DataTemplate DataType="{x:Type viewModel:DiscoveryViewModel}">
                <view:DiscoveryView/>
            </DataTemplate>
        </ResourceDictionary>
    </Application.Resources>
</Application>

```

注册完后就可以在控件中进行使用了

```xaml
 <RadioButton Content="Home"
              Height="50"
              Foreground="White"
              FontSize="14"
              Style="{StaticResource MenuButtonTheme}"
              Command="{Binding HomeViewCommand}"/>
```

# 设置窗体的数据上下文(DataContext)

可以在 code-behind 中进行设置，也可以在窗体对应的 xaml 中进行设置

## 在 xaml 文件中进行设置

直接设置声明 <Window.DataContext> 标签即可

```xaml
<Window x:Class="WPFLocalization.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WPFLocalization"
        xmlns:viewModel="clr-namespace:WPFLocalization.MVVM.ModelAndView"
        mc:Ignorable="d">
    <Window.DataContext>
        <viewModel:MainViewModel/>
    </Window.DataContext>
</Window>
```

其中 MainViewModel 对应的文件是 `WPFLocalization/MVVM/ModelAndView/MainViewModel.cs`

# Element Tree

## Element Tree 的分类

- Visual Tree: It signifies all the UI elements which are rendered to the output screen. 表示在页面中展示的元素
- Logical Tree:In WPF applications, the structure of the UI elements in XAML represents the logical tree structure

### Logical Tree Structure

The logical tree in WPF defines the following：WPF 中的逻辑树定义了如下的内容

- Dependency properties
- Static and dynamic resources
- Binding the elements on its name etc.

### Viusal Tree Structure

In WPF applications, visual tree is used for：

- Rendering the visual objects.
- Rendering the layouts.
- **The routed events mostly travel along the visual tree, not the logical tree**.

可视化树指的是程序运行之后的一个树结构

![image-20220525122035732](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220525122035732.png)

## Summary

- The visual tree is typically a superset of the logical tree.

- The logical tree leaves out a lot of detail enabling you to focus on the core structure of the user interface and to ignore the details of exactly how it has been presented.
- The logical tree is what you use to create the basic structure of the user interface.
- The visual tree will be of interest if you're focusing on the presentation. For example, if you wish to customize the appearance of any UI element, you will need to use the visual tree.

# Commands 的使用

参考链接：

- [https://www.c-sharpcorner.com/UploadFile/e06010/wpf-icommand-in-mvvm/](https://www.c-sharpcorner.com/UploadFile/e06010/wpf-icommand-in-mvvm/)
- [官网](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/commanding-overview?view=netframeworkdesktop-4.8)
- [MVVM - Commands, RelayCommands and EventToCommand](https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/may/mvvm-commands-relaycommands-and-eventtocommand) 推荐阅读

Commands provide a way to search the element tree for a command handler.

In this article, I take a closer look at one of the important components of any Model-View-ViewModel application: the command. Historically, the .NET Framework has always been an event-based framework: **a class exposes an event that is raised by the class instances when subscribers need to be notified. On the other hand, the subscribers provide an EventHandler, which is typically a method with two parameters: the sender of the event and an instance of a class deriving from EventArgs.** When the event is raised, the event-handling method is executed and the EventArgs instance carries additional information (if available) about what caused the event in the first place.

data-bindings are evaluated only at run time

- The method Execute(object) is called when the command is actuated. It has one parameter, which can be used to pass additional information from the caller to the command.
- The method CanExecute(object) returns a Boolean. If the return value is true, it means that the command can be executed. The parameter is the same one as for the Execute method. When used in XAML controls that support the Command property, the control will be automatically disabled if CanExecute returns false.
- The CanExecuteChanged event handler must be raised by the command implementation when the CanExecute method needs to be reevaluated. In XAML, when an instance of ICommand is bound to a control’s Command property through a data-binding, raising the CanExecuteChanged event will automatically call the CanExecute method, and the control will be enabled or disabled accordingly.

Note that in Windows Presentation Foundation (WPF), the CanExecuteChanged event does not need to be raised manually. A class named CommandManager is observing the user interface and calls the CanExecute method when it deems it necessary. In all other XAML frameworks, however (including Windows RT), the developer must take care of raising this event when it’s needed.

Of course, having to implement the ICommand interface every time a command must be added to the project is impractical. This is why some of the most popular frameworks and toolkits in .NET offer a generic implementation of ICommand.

## The RelayCommand

In the MVVM Light Toolkit, the open-source toolkit described in [the previous articles in this series](https://msdn.microsoft.com/en-us/magazine/jj694937.aspx), the ICommand implementation is called RelayCommand. The constructor of this class has two parameters:

- **The first parameter is compulsory**. It is used for the Execute method that the ICommand interface requires. For example, a lambda expression can be used as shown in **Figure 3**. Alternatively, the syntax shown in **Figure 2** can be used, where a delegate to a method is provided for the Execute parameter. 第一个参数是必须要传递的，第一个参数是delegate 累心, 因此可以传递方法名或者 lambda 表达式，因为 lambda 表达式最终会被编译成 delegate 类型
- The second parameter is optional. It is a delegate for the CanExecute method that’s specified by ICommand. This delegate must return a Boolean. Here, too, a lambda expression can be used, as shown in **Figure 2**, as can a delegate to a method defined somewhere else.

## Commands 的意义

1. 将命令和处理逻辑分隔开。这就意味着同一个处理逻辑可以被多个控件使用
2. 可以指示某个动作是否可以被执行

A command can indicate whether an action is possible by implementing the [CanExecute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.icommand.canexecute) method. A button can subscribe to the [CanExecuteChanged](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.icommand.canexecutechanged) event and be disabled if [CanExecute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.icommand.canexecute) returns `false` or be enabled if [CanExecute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.icommand.canexecute) returns `true`.

When an application handles the [Executed](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager.executed) event, it has access to the target of the command and can take appropriate action depending on the target's type.

## Commands 的四大概念

- The *command* is the action to be executed。命令指的是要执行的动作
- The *command source* is the object which invokes the command. 命令源指的是调用命令的对象
- The *command target* is the object that the command is being executed on. 命令目标指的是在哪个对象上执行该命令
- The *command binding* is the object which maps the command logic to the command. 命令绑定是将命令逻辑绑定到命令的对象

It is worth noting that it is not always the case that the `CommandBinding` is supplied by the control that is the command target class.

值得注意的是，CommandBinding 并不总是由命令目标(Command Target)类提供的

the `CommandBinding` must be created by the application developer, or the `CommandBinding` might be attached to an ancestor of the command target.

CommandBiding 一定要由应用开发人员创建，否则命令绑定可能会连接到命令目标的祖先元素上

## CommandBinding

A `CommandBinding` associates a command with the `PreviewExecuted/Executed` and `PreviewCanExecute/CanExecute` events which implement and determine the status of the command.

CommandBinding 将一个命令与 PreviewExecuted/Executed 和 PreviewCanExecute/CanExecute 事件关联起来，这些事件实现和决定了对应命令的状态

`CommandBinding` Binds a `RoutedCommand` to the event handlers that implement the command.

CommandBinding 会将实现了 RoutedCommand 的命令绑定到事件处理器中

When the `Execute` or `CanExecute` method of a `RoutedCommand` is called, the `PreviewExecuted/Executed` or the `PreviewCanExecute/CanExecute` events are raised on the command target. If the command target has a `CommandBinding` for the command, the appropriate handlers are called. If the command target does not have a `CommandBinding` for the command, the events are routed through the element tree until an element that has a `CommandBinding` is found.

当 RoutedCommand 中的 Execute 和 CanExecute 方法被调用时，PreviewExecuted/Executed 或者 PreviewCanExecute/CanExecute 事件就会在 Command Target 中被发起。如果 Command Target 中有对应命令的 CommandBinding, 那么恰当的处理器就会调用，如果没有，那么事件就会从当前节点开始往 Element Tree 向上查找其祖先结点，直到找到一个有 CommandBinding 的祖先节点 

A `CommandBinding` has limited use with an `ICommand` that is not a `RoutedCommand`. This is because a `CommandBinding` binds the command to the `ExecutedRoutedEventHandler` and the `CanExecuteRoutedEventHandler` which listen to the `Executed` and `CanExecute` routed events which are raised when the `Execute` and `CanExecute` method of the `RoutedCommand` are called.

**CommandBinding 对一个非 RoutedCommand 的 ICommand 的作用是有限**。这是因为 CommandBinding 会将命令绑定到 ExecutedRoutedEventHandler 和 CanExecutedEventHander 中，这两个 Handler 会监听 RoutedCommand 中的 Execute 和 CanExecute 方法，当这两个被调用时会引发 Executed 和 CanExecuted 路由事件。 

## 系统预定义 Commands

Predefined Commands，所有预定义的 Commands 可以参考如下链接

参考链接：[https://stackoverflow.com/questions/1574788/wpf-built-in-commands](https://stackoverflow.com/questions/1574788/wpf-built-in-commands)

## 自定义 Command

自定义 Comand 需要实现 ICommand 接口。ICommand 接口有两个方法：Execute,CanExecute和一个事件: CanExecuteChanged

- `Execute` performs the actions that are associated with the command. 

- `CanExecute` determines whether the command can execute on the current command target.

- `CanExecuteChanged`is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding.

  如果集中管理命令操作的命令管理器在命令源(Command Source)中检测到可能会让一个已经发生但没有被执行的命令绑定(Command Binding)失效的变化，那么 CanExecuteChanged 事件就会被发起

*CanExecuteChanged* notifies any command sources (like a Button or CheckBox) that are bound to that ICommand that the value returned by CanExecute has changed. Command sources care about this because they generally need to update their status accordingly (eg. a Button will disable itself if CanExecute() returns false).

CanExecuteChanged 会通知所有绑定到 CanExecuteChanged 所在的 ICammand 的命令源，告知他们 CanExecute 方法的返回值发生了变化。命令源关心 CanExecute 方法的返回值是为了在其发生变化时，对应的更新自身的状态

## RoutedCommand

The `Execute` and `CanExecute` methods on a `RoutedCommand` do not contain the application logic for the command as is the case with a typical ICommand，but rather, these methods raise events that traverse the element tree looking for an object with a [CommandBinding](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandbinding?view=windowsdesktop-6.0). The event handlers attached to the [CommandBinding](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandbinding?view=windowsdesktop-6.0) contain the command logic.

RoutedCommand 中的 Execute 和 CanExecute 方法并没有像典型的 ICommand 那样实现应用的逻辑，但是，这些方法发起了遍历 Element Tree 的事件，这个事件的目的是从 Element Tree 中找到有 CommandBinding 的对象, 这个事件的处理器会连接到包含命令逻辑的 CommandBinding 对象中

WPF中命令的核心是 `System.Windows.Input.ICommand` 接口，所有命令对象都实现了此接口。当创建自己的命令时，不能直接实现 `ICommand` 接口，而是要使用 `System.Windows.Input.RouteCommand` 类，该类已经实现了 `ICommand` 接口，所有 WPF 命令都是 RouteCommand 类的实例。在程序中处理的大部分命令不是 RoutedCommand 对象，而是 RoutedUICommand 类的实例，它继承自 RouteCommand 类。

## 执行流程

The main sources of input in WPF are the mouse, the keyboard, ink, and routed commands. The more device-oriented inputs use a [RoutedEvent](https://docs.microsoft.com/en-us/dotnet/api/system.windows.routedevent) to notify objects in an application page that an input event has occurred.

在 WPF 中，主要的输入源是鼠标，键盘，Ink 和路由命令。很多的面向设备的输入使用 RoutedEvent 来通知应用中的对象有输入事件发生了 

The [Execute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand.execute) and [CanExecute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand.canexecute) methods of a [RoutedCommand](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand) do not contain the application logic for the command, but rather they raise routed events that tunnel and bubble through the element tree until they encounter an object with a [CommandBinding](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandbinding). The [CommandBinding](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandbinding) contains the handlers for these events and **it is the handlers that perform the command.** (这是一个强调句)

RoutedCommand 中的 Execute 和 CanExecute 方法并没有包含任何的处理逻辑，但是这两个方法会发起一个在 Element Tree 中从当前节点向上传递的一个事件。该事件在没有遇到一个拥有 CommandBinding 的 Element 之前，会一直向上传递。因为 CommandBinding 中拥有这些事件的处理程序，同时也正是这些处理程序在执行命令

The [Execute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand.execute) method on a [RoutedCommand](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand) raises the [PreviewExecuted](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager.previewexecuted) and the [Executed](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager.executed) events on the command target. The [CanExecute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand.canexecute) method on a [RoutedCommand](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.routedcommand) raises the [CanExecute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager.canexecute) and [PreviewCanExecute](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager.previewcanexecute) events on the command target. These events tunnel and bubble through the element tree until they encounter an object which has a [CommandBinding](https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandbinding) for that particular command.

RoutedCommand 中的 Execute 方法会在命令目标中引发 PreviewExecuted 和 Executed 事件。RoutedCommand 中的 CanExecute 方法会在 Command target 中引发 CanExecute 和 PreviewCanExecute 事件。这些事件会从命令目标开始在 element tree 中向上传递, 直到遇到一个拥有能够处理这些事件的 CommandBinding 的 Element。

## 隐藏按钮

```ini
button.Visibility = Visibility.Hidden;
button.Visibility = Visibility.Collapsed;
```

`Hidden` hides the button but the button will still take up space in the UI

`Collapsed` will collapse the button such that it has zero width and height.

# ContentControl

Represents a control with a single piece of content of any type. 

表示一个可以展示任何类型内容的控件

The ContentControl can contain any type of common language runtime object (such as a string or a DateTime object) or a UIElement object (such as a Rectangle or a Panel). This enables you to add rich content to controls such as Button and CheckBox。

# FrameworkElement

[FrameworkElement](https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement?view=windowsdesktop-6.0) is the connecting point between WPF framework-level element classes and the WPF core-level set of [UIElement](https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement?view=windowsdesktop-6.0) presentation services.

FrameworkElement 是 WPF 框架级元素和 WPF 核心 UIElement 展示服务的连接点 

 [FrameworkElement](https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement?view=windowsdesktop-6.0) deliberately does not define a content model, and leaves that responsibility to derived classes.

FrameworkElement 没有定义内容模型，它把构建内容模型的任务交给了他的的派生类

[FrameworkElement](https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement?view=windowsdesktop-6.0) extends [UIElement](https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement?view=windowsdesktop-6.0) and adds the following capabilities

FrameworkElement 继承自 UIElement，但是增加如下的几个属性：

- 定义布局系统
- 逻辑树
- 对象生命周期事件: WPF 实现的事件 [Initialized](https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement.initialized), [Loaded](https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement.loaded), and [Unloaded](https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement.unloaded) lifetime events
- 支持数据绑定和动态资源的引用
- 定义样式
- 支持更多的动画特效

 参考文章：[Object lifetime events (WPF .NET)](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/events/object-lifetime-events?view=netdesktop-6.0)

# Geoetry 几何图形组件

**The [Path](https://docs.microsoft.com/en-us/dotnet/api/system.windows.shapes.path) class enables you to draw curves and complex shapes.** These curves and shapes are described using [Geometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.geometry) objects. To use a [Path](https://docs.microsoft.com/en-us/dotnet/api/system.windows.shapes.path), you create a [Geometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.geometry) and use it to set the [Path](https://docs.microsoft.com/en-us/dotnet/api/system.windows.shapes.path) object's [Data](https://docs.microsoft.com/en-us/dotnet/api/system.windows.shapes.path.data) property.

Path 类允许我们画出曲线和复杂图形。这些曲线和图形通过 Geometry 对象来进行描述。为了使用 Path 类，我们需要创建一个 Geometry 对象并将它设置到 Path 对象的 Data 属性上

There are a variety of [Geometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.geometry) objects to choose from. The [LineGeometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.linegeometry), [RectangleGeometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.rectanglegeometry), and [EllipseGeometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.ellipsegeometry) classes describe relatively simple shapes. To create more complex shapes or create curves, use a [PathGeometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pathgeometry).

WPF 中有多种 Geometry 对象供我们选择。`LineGeometry`, `RectangleGeometry`, and `EllipseGeometry` 提供了相对简单的图形。如果需要创建复杂的图形和曲线，需要使用 `PathGeometry`

More complex geometries can be created by using the [PathGeometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pathgeometry) and [StreamGeometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.streamgeometry) classes, which enable you to describe arcs and curves.

可以使用 PathGeometry 和 StreamGeometry 类来创建更为复杂的图形，因为这两个类可以描述弧线和曲线

Because a [Geometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.geometry) is a type of [Freezable](https://docs.microsoft.com/en-us/dotnet/api/system.windows.freezable), [Geometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.geometry) objects provide several special features: they can be declared as [resources](https://docs.microsoft.com/en-us/dotnet/desktop-wpf/fundamentals/xaml-resources-define), shared among multiple objects, made read-only to improve performance, cloned, and made thread-safe.

由于 Geometry 是一种 Freezable 类型，因此 Geometry 对象有如下的特性：

- 可以作为被多个对象共享的一种资源
- 只读属性可以提高它执行和克隆的性能同时保证它是线程安全的

### PathGeometry and PathSegments

[PathGeometry](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pathgeometry) objects are comprised of one or more [PathFigure](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pathfigure) objects; each [PathFigure](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pathfigure) represents a different "figure" or shape. Each [PathFigure](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pathfigure) is itself comprised of one or more [PathSegment](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pathsegment) objects, each representing a connected portion of the figure or shape. Segment types include the following: [LineSegment](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.linesegment), [BezierSegment](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.beziersegment), and [ArcSegment](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.arcsegment).

`PathGeometry` 对象是由一个或者多个 `PathFigure` 对象组合而成的。每一个 `PahtFigure` 对象代表一个不同的图形或者形状。每一个 `PathFigure` 又是由一个或者多个 `PathSegment` 对象组成的。每一个`PathSegment` 代表图形连接的一部分。Segment 的类型有：`LineSegment`, `BezierSegment`，`ArcSegment`



#### 绘制图形的原理

**Geometry 由多个 Figure 组成，Figure 由多个 Segment 组成，而 Segment 又由多个 Point 连接而成。**

一个 Figure 由多个 Segment 组成，在 Figure 中指定起点，然后在每个 Segment 中指定终点，一个 Segment 的终点是下一个 Segment 的起点，这些点按照添加的顺序连接起来就会绘制成了图形

一个 Geometry 至少一个 Figure ，一个 Figure 至少一个 Segment，即：

```csharp
Geometry geometry = new Geometry();
Figure figure = new Figure();
PathSegment segment = new PathSegment();
figure.StartPoint = ...; // 起点
segment.Points.clear()// 避免重复添加，因为渲染一个图形时，有时会多次调用同一个方法。反正每次在添加前先调用一次这个方法就对了，能够少遇见一些坑
segment.Points.Add(new Point(...)); // 添加描述 Segment 的点
segment.Points.Add(new Point(...)); // 添加描述 Segment 的点
.....
fiogure.Segments.clear(); // 避免重复添加，因为渲染一个图形时，有时会多次调用同一个方法。反正每次在添加前先调用一次这个方法就对了，能够少遇见一些坑
figure.Segments.Add(segment);
geometry.figures.clear();// 避免重复添加，因为渲染一个图形时，有时会多次调用同一个方法。反正每次在添加前先调用一次这个方法就对了，能够少遇见一些坑
geometry.figures.Add(figure);
```

# Routed Event

在 WPF 中可以使用 routed event 在 Element Tree 中传播事件，从而调用 Element Tree 中监听器对应的处理器程序。在 CLR(Common Language Runtime) 中没有这样的事件。

在 WPF 中有很多 Routed Event，例如 ButtonBase.Click 事件

Routed events enable an element to handle an event that was raised by a different element, as long as the elements are connected through a tree relationship.

Routed events 允许 element tree 中的 element 处理其他 element 传播过来的事件，只要这些元素之间是通过树关系关联起来的

When specifying event handling with a XAML attribute, the routed event can be listened for and handled on any element, including elements that don't list that particular event in the class members table.

当我们在 XAML 的属性值中绑定了一个事件处理时，routed event 可以被任何元素监听和处理，包括那些没有在类成员表中列出那个指定事件的元素

This is accomplished by qualifying the event name attribute with the owning class name. 

可以通过 `类名.事件名` 来完成绑定，例如

```xaml
<StackPanel Button.Click="Button_Click">
    <Button>Click Me</Button>
    <Button>Click Me</Button>
    <Button>Click Me</Button>
</StackPanel>
<Button>Outer Button</Button>
```

上述的声明中，会为 `StackPanel` 中的所有 Button 都注册 Click 事件，而外面的那个 Outer Button 不会被注册 Click 事件

## What is a routed event?

You can consider routed events from a functional or implementation perspective:

我们可以从功能和实现的角度来考虑 routed event

- From a **functional** perspective, a routed event is a type of event that can invoke handlers on multiple listeners in an element tree, not just on the event source. An event listener is the element where an event handler is attached and invoked. An event source is the element or object that originally raised an event.

  从功能的角度上来看，一个 routed event 时一个可以被任何处于 elememnt tree 中的 element 监听并处理的一个事件，而不是只能够被事件源进行处理。事件监听器是一个 element，该 element 用于连接和调用事件处理程序。事件源指的是第一个传播事件 element

- From an **implementation** perspective, a routed event is an event registered with the WPF event system, backed by an instance of the [RoutedEvent](https://docs.microsoft.com/en-us/dotnet/api/system.windows.routedevent) class, and processed by the WPF event system. Typically, a routed event is implemented with a CLR event "wrapper" to enable attaching handlers in XAML and in code-behind as you would a CLR event.

  从实现的角度上看，routed event 表示的是在 WPF 事件系统中注册的，由 RoutedEvent 类的实例对象支撑的并由 WPF 事件系统处理的事件。通常，routed event 是使用 CLR event wrapper(包装器) 来实现的，这使得它能够像一个 CLR event 那样连接到 XAML 和 code-behind 的程序中

Depending on how a routed event is defined, when the event is raised on a source element it:

当事件从事件源开始传播时，如何传播取决于 routed event 定义的方式

- Bubbles up through element tree from the source element to the root element, which is typically a page or window. 从事件源向 root element 传播
- Tunnels down through the element tree from the root element to the source element.从 root element 到事件源
- Doesn't travel through the element tree, and only occurs on the source element.不进行传播，只在事件源中进行处理

> The element that originally raised a routed event is identified as the [RoutedEventArgs.Source](https://docs.microsoft.com/en-us/dotnet/api/system.windows.routedeventargs.source#system-windows-routedeventargs-source) in the event handler parameters. 
>
> The event listener is the element where the event handler is attached and invoked, and is identified as the [sender](https://docs.microsoft.com/en-us/dotnet/api/system.windows.routedeventhandler) in the event handler parameters. sender 就是事件处理器连接和调用事件处理程序的元素

例如

```xaml
<StackPanel Button.Click="Button_Click">
    <Button>Click Me</Button>
    <Button>Click Me</Button>
    <Button>Click Me</Button>
</StackPanel>
```

```csharp
private void Button_Click(object sender, RoutedEventArgs e)
{
    StackPanel stackPanel = (StackPanel)sender;
    Button btn = (Button)e.Source;
    stackPanel.Background = new SolidColorBrush(Colors.Red);
    MessageBox.Show("Hello Routed Event");   
}
```

从上面的程序中可以看出: sender 是 StackPanel，也就是说是 StackPanel 调用的 Button_Click 事件处理函数

## routed event 的高级应用场景

- 控件的组装和封装：一个按钮里面的内容可以是一个图片，但是放置这个图片之后不能够影响按钮的碰撞测试，例如点击，即我们点击图片的任何地方，按钮的点击事件都不能够失效，需要被正确的响应和处理
- 单一处理程序连接点：例如多个按钮都放在 StackPanel 中，并且都需要注册 Click 点击事件，此时我们不需要在每个按钮中都注册 Click 事件，只需要在 StackPanel 中注册一个就好了，这样做的好处就是我们可以随意添加和删除按钮，而不需要去关心它是否注册了点击事件
- 类处理：Routed events support a [class event handler](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/events/marking-routed-events-as-handled-and-class-handling?view=netdesktop-6.0#instance-and-class-routed-event-handlers) that you define in a class. Class handlers handle an event before any instance handlers for the same event on any instance of the class.
- 引用没有反射的事件: 每一个 routed event 都会创建一个 RoutedEvent 字段标识符用于提供健壮的事件识别技术。这种方式不需要依赖静态和运行时反射技术来识别事件

## Routed event 是如何实现的

routed event 是 WPF 事件系统中存在的一个事件，它由 RoutedEvent 类的实例支撑并被 WPF 的事件系统处理。从 [registration](https://docs.microsoft.com/en-us/dotnet/api/system.windows.eventmanager.registerroutedevent) 中获得的 RoutedEvent 实例通常存储在注册 RoutedEvent 事件的类的一个 `public static readonly` 成员中，引用 RoutedEvent 事件的类成为 owner 类。通常一个 routed event 会实现一个名字相同的 CLR event wrapper(CLR 事件包装器)。这个 CLR event wrapper 使用 `add` 和 `remove` 两个访问器并使用特定的事件语法来连接 XAML 和 code-behind 中的事件处理程序。`add` 和 `remove` 访问器会覆盖 CLR 的实现并调用 routed event 的 `AddHandler` 和 `RemoveHandler` 方法。routed event 的支持和连接机制在概念上类似于依赖属性是一个由 DependencyProperty 类支持并注册到 WPF 属性系统的 CLR 属性

```csharp
// Register a custom routed event using the Bubble routing strategy.
public static readonly RoutedEvent TapEvent = EventManager.RegisterRoutedEvent(
    name: "Tap",
    routingStrategy: RoutingStrategy.Bubble,
    handlerType: typeof(RoutedEventHandler),
    ownerType: typeof(CustomButton));

// Provide CLR accessors for adding and removing an event handler.
public event RoutedEventHandler Tap
{
    add { AddHandler(TapEvent, value); }
    remove { RemoveHandler(TapEvent, value); }
}
```

## Routing Strategies

- Bubbling
- Tunneling
- Direct

官方网址: [https://docs.microsoft.com/en-us/dotnet/desktop/wpf/events/routed-events-overview?view=netdesktop-6.0#routing-strategies](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/events/routed-events-overview?view=netdesktop-6.0#routing-strategies)

## ContextMemu 属性

A ContextMenu, **offen referred to as popup or pop-up menu**, is a menu which is shown upon certain user actions, usually a right-click with the mouse on a specific control or window. Contextual menus are often used to offer functionality that's relevant within a single control

# TemplateBinding

通过 TemplateBinding 可以将外部控件的属性和 Template 中控件的属性连接起来，从而在使用时，动态的填充 Template 中的内容

```xaml
<Button
x:Name="buttonExit"
Width="80" Height="26" Content="Exit"
HorizontalContentAlignment="Center"
HorizontalAlignment="Center"
Click="buttonExit_Click">
    <Button.Template>
		<ControlTemplate>
			<Grid Width="80"
				  HorizontalAlignment="Center" >
				<Rectangle RadiusX="10"
                           Fill="Orange"
						   Stroke="Black"
                           RadiusY="10"/>
				<ContentPresenter Content="{TemplateBinding Button.Content}"
						          FontSize="12"
                                  Width="50"
                                  HorizontalAlignment=" {TemplateBinding Button.HorizontalAlignment} "
 								  VerticalAlignment="Center" >
				</ContentPresenter>
			</Grid>
		</ControlTemplate>
	</Button.Template>
</Button>

```

```xaml
<ContentPresenter Content="{TemplateBinding Button.Content}"
```

这个绑定的左右就是，当我们设置 Button 控件的 Content 属性时，ContentPresenter 中的 Content 属性会自动同步的更新成 Button.Content 的内容

# Control States

Visual State Manager and VisualState are using to define States of control and using each state that you
can customize the appearance of control.

You use VisualState objects to specify the appearance of a control when it is in a certain state. A VisualState contains a Storyboard that changes the appearance of the elements that are in the ControlTemplate.

**Not apply ViewState and VisualStateManager for ComboBox control**

# Themes

WPF themes are defined by using the styling and template mechanism that it exposes for customizing the visuals of any element.

WPF provides support for packaging user interface (UI) resources as a theme by using a resource dictionary that is encapsulated as the ResourceDictionary class.

WPF theme resources are stored in embedded resource dictionaries. These resource dictionaries must be embedded within a signed assembly, and can either be embedded in the same assembly as the code itself or in a side-by-side assembly.

# Resource Dictionary

The desktop themes determine which resource dictionary is used. To get the resource dictionaries for the desktop themes. The following table describes the resource dictionary file names and their corresponding desktop themes.

| Theme file              | Desktop theme                                                |
| :---------------------- | :----------------------------------------------------------- |
| Classic.xaml            | Classic Windows look (from Windows 95, Windows 98, and Windows 2000) on the Windows XP operating system.. |
| Luna.NormalColor.xaml   | Default blue theme on Windows XP.                            |
| Luna.Homestead.xaml     | Olive theme on Windows XP.                                   |
| Luna.Metallic.xaml      | Silver theme on Windows XP.                                  |
| Royale.NormalColor.xaml | Default theme on the Windows XP Media Center Edition operating system. |
| Aero.NormalColor.xaml   | Default theme on the Windows Vista operating system.         |

## WPF Resources

A resource can be referenced as either a static resource or a dynamic resource. This is done by using either the `StaticResource` Markup Extension or the `DynamicResource` Markup Extension.

A markup extension is a feature of XAML whereby you can specify an object reference by having the markup extension process the attribute string and return the object to a XAML loader. Default is DynamicResource.

扩展标记是 xaml 文件的一个特性，通过该特性可以在 xaml 中指定一个对象的引用并通过扩展标记来处理对应的引用，最终返回一个对象给 xaml 加载器。资源引用的方式默认是 `DynamicResource`

Every WPF control there has a `Resources` property so you can specify the Resources and here they are.

可以在 Resources 属性中定义 ControlTemplate

### Window.Resources

在 Window.Resources 属性中定义的资源，可以被该窗体中包含的所有控件所使用

ComboBox are slightly different in some specialty properties than other controls,they simply serve as a way to describe an interface to which a control must conform.

# Data Binding

Source: 指的是 code-behind 中的数据

destination: 指的是组件

## Data Binding Modes

Data Binding usually flows from the source to the destination. There are five data
binding modes.

- OneWay: From source to destination.
- TwoWay: Changes to source and destination are copied to each other.
- OneTime: The property is initially set, but updates to the source are not copied to the destination.
- OneWayToSource: A reverse version of OneWay.

![Data binding overview - WPF .NET | Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/media/index/databinding-dataflow.png?view=netdesktop-6.0)

![Everything you wanted to know about databinding in WPF, Silverlight and WP7  (Part Two)](https://blog.scottlogic.com/archive/2012/04/BindingMarkup.png)

### Trigger Source Updates

Data Bindings that are TwoWay or OneWayToSource listen for changes in the target property and propagate them back to the source.

## ADO.NET and CRUD

ADO.NET provides consistent access to data sources such as SQL Server and XML, and to data sources exposed through OLE DB and ODBC.

Data-sharing consumer applications can use ADO.NET to connect to these data sources and retrieve, handle, and update the data that they contain.

###  ADO.NET Data Providers

ADO.NET includes .NET Framework data providers for connecting to a database, executing commands, and retrieving results.

The following table lists the data providers that are included in the .NET Framework and use for relational databases.

| .Net Data Provider                                       | Description                                                  |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| .Net Framework Data Provider for SQL Server              | Provides data access for Microsoft SQL Server.<br/>Uses the `System.Data.SqlClient` namespace. |
| .NET Framework Data Provider for OLE DB                  | For data sources exposed by using OLE DB.<br/>Uses the `System.Data.OleDb` namespace. |
| .NET Framework Data Provider for ODBC                    | For data sources exposed by using ODBC.<br/>Uses the `System.Data.Odbc` namespace. |
| .NET Framework Data Provider for Oracle                  | For Oracle data sources. The .NET Framework<br/>Data Provider for Oracle supports Oracle client<br/>software version 8.1.7 and later, and uses the<br/>`System.Data.OracleClient` namespace. |
| EntityClient Provider                                    | Provides data access for Entity Data Model (EDM) applications.<br />Uses the `System.Data.EntityClient` namespace. |
| .NET Framework Data Provider for SQL Server Compact 4.0. | Provides data access for Microsoft SQL Server Compact 4.0.<br />Uses the `System.Data.SqlServerC` enamespace. |

Below is a screenshot of how the Core Objects of .NET Framework Data Providers looks like.

| Object      | Decription                                                   |
| ----------- | ------------------------------------------------------------ |
| Connection  | Establishes a connection to a specific data source. The base class for all Connection objects is the DbConnection class. |
| Command     | Executes a command against a data source. Exposes Parameters and can execute in the scope of a Transaction from a Connection. The base class for all Command objects is the DbCommand class. |
| DataReader  | Reads a forward-only, read-only stream of data from a data source. The base class for all DataReader objects is the DbDataReader class. |
| DataAdapter | Populates a DataSet and resolves updates with the data source. The base class for all DataAdapter objects is the DbDataAdapter class. |

# Entity Framework

Entity Framework (EF) is an open source object-relational mapping (ORM) framework for ADO.NET (EF belong to ADO.NET family). I was a part of .NET Framework and designed from the scratch as a lightweight, flexible, and extensible ORM system. It further enables developers to build a variety of applications by targeting various platforms, devices, and deployment.

But since Entity framework version 6 it is separated from .NET framework, they are Entity Framework and Entity Framework Core.

## Entity Framework 6

- As an O/RM, Entity Framework 6 reduces the impedance mismatch between the relational and object-oriented worlds, enabling developers to write applications that interact with data stored in relational databases using strongly-typed .NET objects that represent the application's domain, and eliminating the need for a large portion of the data access "plumbing" code that they usually need to write.
- **EF6 runs on the .NET Framework 4.x, which means it runs only on Windows**.
- EF6 continues to be a supported product, and will continue to see bug fixes and minor improvements.

## Entity Framwork Core

- It is a lightweight, extensible, open source and cross-platform version of the popular Entity Framework data access technology.
- It was first released in 2016. It ships in Nuget packages, the main one being Microsoft.EntityFrameworkCore.
- EF Core is a cross-platform product that can run on .NET Core or .NET Framework.

EF Core was designed to provide a developer experience similar to EF6. Most of the top-level APIs remain the same, so EF Core will feel familiar to developers who have used EF6 and later.

# WPF Commanding

Commands in WPF are created by implementing the ICommand interface. In other hands, the WPF implementation of ICommand is the RoutedCommand class

- Execute performs the actions that are associated with the command. **The Execute method on a RoutedCommand raises the PreviewExecuted and the Executed events on the command target.**
- CanExecute determines whether the command can execute on the currentcommand target. **The CanExecute method on a RoutedCommand raises the CanExecute and PreviewCanExecute events on the command target.**
- CanExecuteChanged is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding.

These events tunnel and bubble through the element tree until they encounter an object which has a CommandBinding for that particular command.

Many controls do provide implementation logic for many of the commands in the command library. For example, the Button class provides logic for the New, Save, Delete, Find, Print, Open and Close commands.

| Properties | Description                                        |
| ---------- | -------------------------------------------------- |
| Close      | Gets the value that represents the Close Command.  |
| Delete     | Gets the value that represents the Delete Command. |
| Find       | Gets the value that represents the Find Command.   |
| New        | Gets the value that represents the New Command.    |
| Open       | Gets the value that represents the Open Command.   |
| Save       | Gets the value that represents the Save Command.   |
| Print      | Gets the value that represents the Print Command.  |

# Dependency Properties

Dependency Properties offer a lot of functionalities that you won’t get by using a CLR property. In contrast with CLR Properties, they are not stored in local object instead of stored in a dictionary of key/value pairs which is provided by the DependencyObject class. So, **it saves a lot of memory because it stores the property when changed.**

### 依赖属性注册的方法

DependencyProperty.Register() 方法用于给控件注册依赖属性，它有如下几种重载的方法

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Register(String, Type, Type)                                 | Registers a dependency property with the specified property name, property type, and owner type. |
| Register(String, Type, Type, PropertyMetadata)               | Registers a dependency property with the specified property name, property type, owner type, and property metadata. |
| Register(String, Type, Type, PropertyMetadata, ValidateValueCallback) | Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property. |

### PropertyMetada 



# Viusal Class

The `Visual` class is the basic abstraction from which every `FrameworkElement` object derives. **It also serves as the entry point for writing new controls in WPF**, and in many ways can be thought of as an equivalent of a window handle (HWND) in the Win32 application model.

The `Visual` object is a core WPF object, whose **primary role is to provide rendering support**

The `Visual` object provides support for the following:

- Output display: Rendering the persisted, serialized drawing content of a visual.
- Transformations: Performing transformations on a visual.
- Clipping: Providing clipping region support for a visual.
- Hit testing: **Determining whether a specified coordinate (point) or geometry is contained within the bounds of a visual.**
- Bounding box calculations: Determining the bounding rectangle of a visual.

## The hierarchy of Visual class

```text
Visual
|----UIElement
|--------FrameworkElement
|----ContainerVisual
|--------DrawingVisual
|--------HostVisual
|----Viewport3DVisual
```

# ToggleButton

A Toggle Button is a control that can switch states, such as CheckBox and RadioButton.

# DependencyProperty

![image-20220601144421759](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220601144421759.png)

A [DependencyProperty](https://docs.microsoft.com/en-us/dotnet/api/system.windows.dependencyproperty?view=windowsdesktop-6.0) supports the following capabilities in Windows Presentation Foundation (WPF):

- The property can be set in a style.
- The property can be set through data binding.
- The property can be set with a dynamic resource reference.
- The property can inherit its value automatically from a parent element in the element tree.
- The property can be animated.
- The property can report when the previous value of the property has been changed and the property value can be coerced. 
- The property reports information to WPF, such as whether changing a property value should require the layout system to recompose the visuals for an element.
- The property receives support in the WPF Designer for Visual Studio. For example, the property can be edited in the **Properties** window.

The main reason to create `DependencyProperty` is when you write you own WPF control. `DependencyProperties` can be used as binding source and target, and can be animated. The properties of all framework's controls are implemented as `DependencyProperty`, that why you can make powerful data binding in XAML.

However in most situation, like in with the MVVM pattern, you don't need dependency properties, `INotifyPropertyChanged` is enough.

The main difference is, that the value of a normal .NET property is read directly from a private member in your class, whereas the value of a DependencyProperty is resolved dynamically when calling the GetValue() method that is inherited from *DependencyObject*.

## What is Dependency Property

WPF has provided some extended services to the CLR property that we can collectively call Dependency Properties. A Dependency Property is a property **whose value depends on the external sources**, such as animation, data binding, styles, or visual tree inheritance. Not only this, but a Dependency Property also has the built-in feature of providing notification when the property has changed, data binding and styling.

## CLR Property VS Dependency Property

A CLR property reads directly from the private member of the class. The Get() and Set() methods of the class retrieve and store the values of the property. 

**Whereas when you set a value of a Dependency Property it is not stored in a field of your object**, but in a dictionary of keys and values provided by the base class DependencyObject. The key of an entry is the name of the property and the value is the value you want to set.

## Advantages of a Dependency Property

- *Less memory consumption*
  The Dependency Property stores the property only when it is altered or modified. Hence a huge amount of memory for fields are free.
- *Property value inheritance*
  It means that if no value is set for the property then it will return to the inheritance tree up to where it gets the value.

- *Change notification and Data Bindings*
  Whenever a property changes its value it provides notification in the Dependency Property using INotifyPropertyChange and also helps in data binding.

- *Participation in animation, styles and templates*
  A Dependency Property can animate, set styles using style setters and even provide templates for the control.

- *CallBacks*
  Whenever a property is changed you can have a callback invoked.

- *Resources*
  You can define a Resource for the definition of a Dependency Property in XAML.

- *Overriding Metadata*
  You can define certain behaviours of a Dependency Property using PropertyMetaData. Thus, overriding a metadata from a derived property will not require you to redefine or re-implement the entire property definition.

## PropertyMetadata vs. FrameworkPropertyMetadata

When you implement a custom dependency property and you register the property by calling **DependencyProperty.Register**, you specify some metadata for the property by passing it an instance of **PropertyMetadata.** This can be an instance of the **PropertyMetadata** class or an instance of one of its subclasses.  The differences are shown below.

**PropertyMetadata**: Basic metadata relating to dependency properties

- **CoerceValueCallback**: coerce the value when being set
- **DefaultValue**: a default value for the property
- **PropertyChangedCallback**: respond to new effective value for the property

**UIPropertyMetadata**: derives from **PropertyMetadata** and adds:

- **IsAnimationProhibited**: disable animations for this property?

**FrameworkPropertyMetadata**: derives from **UIPropertyMetadata** and adds:

- **AffectsArrange, AffectsMeasure, AffectsParentArrange, AffectsParentMeasure, AffectsRender**: Should layout calculations be re-run after property value changes?
- **BindsTwoWayByDefault, DefaultUpdateSourceTrigger, IsDataBindingAllowed, IsNotDataBindable**: Dictates how property participates in data binding
- **Inherits, OverridesInheritanceBehavior**: Does inheritance work for this property?
- **Journal**: Store this value when journaling?
- **SubPropertiesDoNotAffectRender**: Check properties of this object when layout changes?

#### PropertyChangedCallback

```csharp
public delegate void PropertyChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e);
```

- DependencyObject 表示的是依赖属性所在的对象，比如类 A 的依赖属性 B 发生了变化，那么在注册属性 B 中时设置的 PropertyChangedCallback 回调函数中的 DependencyObject 在调用时传递的 DependencyObject 对象就是 A 的实例对象

参考文章

- [WPF Dependency Property](https://www.c-sharpcorner.com/UploadFile/6d590d/wpf-dependency-property/)
- [依赖属性](https://www.5616760.com/wpf/dependency/property/2019/01/05/wpf-dependency-property.html)

# ItemsControl

WPF controls inherit from ItemsControl when they display a collection of items in some fashion. When you want to use data binding to set the collection of items, you don't bind the Items property. Items is actually read-only; you can add and remove items from the list but you cannot replace the collection. Instead of binding Items, you can use the *ItemsSource* property

ItemsSource can be data bound to any sequence that implements the *IEnumerable* interface, although the type of collection used does determine the way in which the control is updated when items are added to or removed. **When ItemsSource is set, the Items property cannot be used to control the displayed values**. If you later set ItemsSource to null, Items becomes usable again.

# Hit Testing

Hit testing support allows you to determine whether a geometry or point value falls within the rendered content of a [Visual](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.visual), allowing you to implement user interface behavior such as a selection rectangle to select multiple objects.

碰撞测试允许你判断一个 *geometry* 或者是 *point* 是否可以落在一个已经渲染完毕的 *Visual* 控件上，允许你实现用户接口行为，例如在矩形选择区域选择多个对象，下面是 *Visual* 的继承图

![image-20220601144421759](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220601144421759.png)

The [UIElement](https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement) class provides the [InputHitTest](https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement.inputhittest) method, which allows you to hit test against an element using a given coordinate value. In many cases, the [InputHitTest](https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement.inputhittest) method provides the desired functionality for implementing hit testing of elements.

*UIElement* 类提供了 *InputHitTest* 方法，该方法允许我们使用坐标在 element 中运行碰撞检测。大多数情况下，*InputHitTest* 方法为实现了碰撞检测的 elements 提供了它们所需要的功能。由于是 UIElement 提供的方法，因此 WPF 中大部分的控件都有该方法， 它们都可以参与到碰撞检测中。那么什么是碰撞检测呢？目前还没有找到官方的文档，我的理解是 WPF 中的大部分事件首先是用碰撞检测来获取事件需要操作的元素，如果获取不到就不能够进行接下来的处理。大部分控件的事件处理，首先要做的就是通过碰撞检测拿到执行事件的控件

The purpose of the [HitTest](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.visualtreehelper.hittest) methods in the [VisualTreeHelper](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.visualtreehelper) class is to determine whether a geometry or point coordinate value is within the rendered content of a given object, such as a control or graphic element.

The WPF visual layer supports hit testing against all objects under a point or geometry, not just the top-most object. Results are returned in z-order. However, the visual object that you pass as the parameter to the [HitTest](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.visualtreehelper.hittest) method determines which portion of the visual tree that will be hit test. You can hit test against the entire visual tree, or any portion of it.

**WPF 可视化层支持坐标或者几何图形下所有对象的碰撞测试，而不是只能够对最顶层对象进行碰撞测试**。测试结果以 Z 轴的顺序返回。传递给 *HitTest* 方法的可视化对象参数将会决定可视化树中的那一部分将会进行碰撞测试。我们可以选择对整棵可视化树进行碰撞测试，也可以对树中的一部分进行可视化测试

If you are only interested in hit testing the visual object whose z-order value is top-most, you can set the visual hit test enumeration to return [Stop](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.hittestresultbehavior#system-windows-media-hittestresultbehavior-stop) from the [HitTestResultCallback](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.hittestresultcallback) to stop the hit test traversal after the first item. If you want to enumerate all visual objects under a specific point or geometry, return [Continue](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.hittestresultbehavior#system-windows-media-hittestresultbehavior-continue) from the [HitTestResultCallback](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.hittestresultcallback).

如果只想对顶层的可视化对象进行碰撞测试，那么可以设置碰撞测试枚举为从 *HitTestResultCallback* 中返回 *Stop*, 用于对第一个可视化对象进行碰撞测试之后阻止继续对树中的其他可视化对象进行碰撞测试。如果想要对所有的可视化对象进行测试，可以从 `HitTestResultCallBack` 返回 `Continue`

If a visual object is found in the visual tree whose geometry contains the coordinate, it is set to the [VisualHit](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.hittestresult.visualhit) property of a [HitTestResult](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.hittestresult) object. The [HitTestResult](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.hittestresult) is then returned from the [HitTest](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.visualtreehelper.hittest) method. If the point is not contained with the visual sub-tree you are hit testing, [HitTest](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.visualtreehelper.hittest) returns `null`.

如果在可视化树中发现树中的某个图形包含可视化对象的坐标，那么它就会设置 *HitTestResult* 对象的 *VisualHit* 属性，并且 *HitTestResult* 对象将会被 *HitTest* 方法返回, 如果没有找到，*HitTest* 方法将会返回 *null*

> Default hit testing always returns the top-most object in the z-order. In order to identify all visual objects, even those that may be partly or wholly obscured, use a hit test result callback.

The coordinate value you pass as the point parameter for the [HitTest](https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.visualtreehelper.hittest) method has to be relative to the coordinate space of the visual object you are hit testing against

传递给 *HitTest* 方法的坐标，必须是相对于碰撞测试对象的相对坐标，如在 A 中进行测试，那么传递给 *HitTest* 方法的坐标就是相对于 A 的坐标，而不是相对于屏幕的坐标，即以 A 对象所包含的区域为参照物，计算坐标

```csharp
// Respond to the left mouse button down event by initiating the hit test.
private void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
{
    // Retrieve the coordinate of the mouse position.
    // 拿到鼠标相当于 sender 的坐标
    Point pt = e.GetPosition((UIElement)sender);

    // Perform the hit test against a given portion of the visual object tree.
    // 在可视化树中的 myCanvas 对象上进行碰撞测试
    HitTestResult result = VisualTreeHelper.HitTest(myCanvas, pt);

    if (result != null)
    {
        // Perform action on hit visual object.
    }
}
```

## IsHitTestVisible

The [IsHitTestVisible](https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement.ishittestvisible) property gets or sets a value that declares whether a [UIElement](https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement)-derived object can possibly be returned as a hit test result from some portion of its rendered content. This allows you to selectively alter the visual tree to determine which visual objects are involved in a hit test.

*IsHitTestVisible* 属性用于获取或者设置某个值，该值用于声明一个基于 *UIElement* 的派生类是否可以从将它所渲染内容的某个部分作为碰撞测试的结果被返回。这个属性允许我们选择性的修改可视化树，从而判断哪些可视化对象参与了碰撞测试

To enumerate visual objects in a visual tree use the *HitTest* method with a hit test callback function. The hit test callback function is **called by the system** when the coordinate value you specify is contained in a visual object.

为了枚举出可视化树种的 visual 对象，需要使用带有碰撞测试回调函数的 HitTest 方法，当一个 visual 对象中包含你指定的坐标时，系统会自动调用你传递的回调函数

During the hit test results enumeration, you **should not** perform any operation that modifies the visual tree. Adding or removing an object from the visual tree while it is being traversed can result in unpredictable behavior. You can safely modify the visual tree after the *HitTest* method returns. 

在执行碰撞测试的过程中，你不应该执行任何修改可视化树的操作。在遍历可视化树的过程中删除或者添加一些对象会造成无法预测的行为。你应该在 HitTest 方法结束后在安全的修改可视化树的内容

If you set IsHitTestVisible="False" on the ToggleButton, then the ToggleButton doesn't listen for input

**IsHitTestVisible is a way to "hide" control components from the input events**

如果在 ToggleButton 控件中设置 *IsHitTestVisible* 属性为 *false* ，那么该控件以及它的子控件都不会在响应事件

# Path

[Path Markup Syntax](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/path-markup-syntax?view=netframeworkdesktop-4.8)

Use a *StreamGeometry* when you don't need to modify the path after creating it

Use a *PathGeometry* if you do need to modify the path.

# Rect 结构体

Rect 结构体描述了 Rectangle 的宽度，高度和位置

[Rect 方法文档](https://docs.microsoft.com/en-us/dotnet/api/system.windows.rect?view=windowsdesktop-6.0#methods)

Rect 结构体可以用于测试两个控件是否发生交叉

通过 Rect 结构体可以轻松的获取矩形四个角落的位置

```csharp
Rect rect = new Rect(...);
rect.TopLeft
rect.TopRight
rect.BottomLeft
rect.BottomRight

```



# TextBox

The `TextBox` in WPF has a lot of built in behavior, from responding to keyboard shortcuts for *copy/paste* to having its own context menu. It even has a built in *spell checker* and *undo stack!* One of these built in features is the ability to *drag selected text* into and out of a `TextBox`. 

## Vector 矢量

Point 表示的是一个固定的点，但是 Vector 代表大小和方向。两个 Point 的差值表示的就是一个 Vector 矢量，即使用 Vector 来表示对应线段的长度和方向, 方向由 Vector 中的 X 和 Y 与原点构成，可以使用 normalize 方法将向量转换成单位向量(向量的长度为 1)

注意：**Vector 是有方向的**，例如：pointA - PointB，则方向为 A -> B，PointB - PointA, 则方向为 B -> A

## Matix

参考文章：[https://www.cnblogs.com/TianFang/p/3920734.html](https://www.cnblogs.com/TianFang/p/3920734.html)

Matrix: 用于二维空间中图形的变换，图形的变换分成**旋转，缩放，扭曲和平移**。注意：这些**变换针对的是点**，在 WPF 中通过一个个的点相互连接来绘制图形

衍射变换的矩阵总是 3 * 3 的。其中最后一列的数据是固定的为 `0,0,1`, 其中 2 * 2 表示线性变化部分，第三行及前两列表示平移变换部分

![img](https://images0.cnblogs.com/blog/12132/201408/182320497064173.gif)

### 复合变换

复合变换的矩阵可通过将几个单独的变换矩阵相乘而得到，这就意味着任何仿射变换的序列均可存储于单个的 Matrix 对象中

![img](https://images0.cnblogs.com/blog/12132/201408/182320503461003.gif)

需要注意的是，复合变换是有顺序的，一般说来，先旋转、再缩放、然后平移，与先缩放、再旋转、然后平移是不同的。

### 逆矩阵

可以根据一定的运算求出某个矩阵的逆矩阵，这个矩阵可以用来求出新的坐标点在原坐标系的位置，但需要注意的是，并非所有矩阵都是可逆的

### Matrix 的使用实例

```csharp
// 1. 初始化一个 Matrix 对象
Matrix matrix = new Matrix();
// 2. 设置点如何变换，可以是旋转，平移，缩放，扭曲中的任何一种
matrix.Rotate(15); // 将点顺时针旋转 15 度，如果是负数，则表示逆时针旋转
// 3. 将    
```

## Canvas

在 code-behind 中使用代码在 Canvas 显示自定义的 Geometry，需要在 xaml 中设置 Canvas 的 background 属性，即使背景色是白色也要设置，不然在 code-behind 中添加到 Canvas 中的 Geometry 将不会显示。

## 转换器 Converter

转换器的作用是允许我们自定义数据绑定的逻辑

### 常用的转换器

- IValueConverter：值转换器，将绑定的一个值转换成另外一个值
- IMultiValueConverter：值转换器，将 MultiBinding 与转换器关联起来

### ValueConversionAttribute

ValueConversionAttribute 表示一个属性，该属性允许开发人员指定转换器实现中涉及的数据类型

## Thumb

Thumb 必须是 Canvas 的直接子类，并且是采用绝对定位的方法，在声明 Thumb 控件的时候必须显示的声明该控件在 Canvas 中的位置，即使是 0,0 也必须设置，**否则** 拖动事件不会生效

### Thumb 的核心事件

DragStarted: 但在 Thumb 控件上点击鼠标左键并拖动时发生一次

DragDelta: 只要 Thumb 控件还在拖动，该事件就会持续的触发

DragCompleted: Thumb 控件拖动结束后触发

## Adorner

该控件是一个装饰器控件，该控件允许我们使用标记处控件的边界。

Adorner 控件是继承自 FrameworkElement 的一个抽象类，由于是抽象类，我们不能够直接使用，需要继承 Adorner 类并实现 OnRender 方法

Adorner 节点不在可视化树中，因此他们不会干涉可视化树中节点的布局

an adorner always has a higher z-order than the element it adorns

## Adorner 的特性

- 因为 Adorner 是在单独的一层，因此它的可视化效果可以在被装饰的控件之上，即使修饰的元素被裁剪过，效果同样如此
- 因为 Adorner 是在单独的一层，因此 Adorder 不会被它所修饰的元素或者它的兄弟控件所覆盖
- 当 Adorner 所修饰的控件的大小和位置发生变化时，Adorner 自发的对这些变化做出响应，这些响应中包括其他普通元素实现起来有些困难的布局响应
- Adorner 可以在不改变已存在的控件或者 panel 等控件模板或者其他结构的情况下添加到这些控件上. 这个特性使得 Adoder 可以在任意控件上提供提供更好的操作和视觉反馈

1. Because adorners are on a separate layer, the visual can extend beyond the adorned element, even if the adorned element is clipped.
2. Because adorners are on a separate layer, they are generally not obscured by the AdornedElement's container or by sibling controls.
3. Adorners are automatically notified of all changes in the size and location of the adorned element, allowing responses to layout changes that are not as easily achieved with ordinary controls.
4. Adorners can be applied to panels and to existing controls without making any changes to their templates or otherwise. This makes them good for providing manipulation handles or visual feedback on arbitrary controls.
5. In many scenarios you will create adorners only for a few "active" items out of hundreds or thousands. Implementing the same functionality using ControlTemplates can be dramatically less efficient if you have to add an additional Panel to the template: Every single instatiation of the template will have the extra panel, whereas there would be just one adorner.

### Adorner 的使用

1. You need to create a class that derives from *Adorner*
2. In the derived class, you either have some custom rendering code or you attach UI elements and visuals as children to the adorner. 
3. you create an instance of your derived adorner class. The UI element that is to be adorned is passed into the constructor of the adorner.
4. the adorner is added to the adorner layer.

All this is achieved procedurally in C# code.

```csharp
class MyAdorner : Adorner {
    public MyAdorner(UIElement adorneredElement): base(adorneredElement){
        // Other initialisation
    }
    
    // Other methods ...
    
    // A common way to implement an adorner's rendering behavior is to override the OnRender
    // method, which is called by the layout system as part of a rendering pass.
    protected override void OnRender(DrawingContext drawingContext){
        base.OnRender(drawingContext)
    }
}
```

When you are ready to display the adorner and allow the user to interact with it **must** be added to the adorner layer.

```csharp
Control parentControl = ...
UIElement adornedElement = ...
// 该方法只有在控件渲染完毕之后获取对应的 AdornerLayer 才会返回一个非 null 的实例对象。因此在 Loeaded 事件中进行操作更为的稳健
AdornerLayer adornerLayer = AdornerLayer.GetAdornerLayer(parentControl);
MyAdorner myAdorner = new MyAdorner(adornedElement);
adornerLayer.Add(myAdorner);
```

The alternative to writing custom rendering code is to add children to the visual tree of the adorner. This means that any class derived from Visual can be instanced and added to the visual tree underneath the adorner. I have used this technique in `FrameworkElementAdorner`.

### 参考文献

- [https://stackoverflow.com/questions/2595166/when-should-i-use-adorners](https://stackoverflow.com/questions/2595166/when-should-i-use-adorners)
- [https://www.codeproject.com/Articles/54472/Defining-WPF-Adorners-in-XAML](https://www.codeproject.com/Articles/54472/Defining-WPF-Adorners-in-XAML)
- [https://stackoverflow.com/questions/13849335/wpf-adorner-appear-on-mouseover-animation-whats-the-best-pattern](https://stackoverflow.com/questions/13849335/wpf-adorner-appear-on-mouseover-animation-whats-the-best-pattern)

## 鼠标捕获

在 WPF 中，只有鼠标在某个控件上时，才会触发对应控件上的鼠标事件。例如有控件 A 和 B，A 和 B 都注册了 MouseDown 和 MouseUp 事件。在 A 控件中按下鼠标左键不释放并将鼠标移动到 B 控件中，那么 A 控件只会出发 MouseDown 事件，B 控件只会触发 MouseUp 事件。同样的，如果控件注册了 MouseMove 事件，如果鼠标移动到控件范围之外，控件也接收不到 MouseMove 事件。

但是在很多情况下，我们希望即使鼠标移动到控件之外，控件仍然能够接收到鼠标事件。例如按住鼠标拖动，当鼠标到了控件外，拖动操作依然可以继续。

这种情况需要强制捕获鼠标，可以使用 UIElement 的 CaptureMouse 方法和 ReleaseMouse 方法来捕获鼠标和释放鼠标。在调用了 CaptureMouse 方法之后，对应的控件会一直捕获鼠标，因此在对应的事件完成之后，需要调用对应的 ReleaseMouse 方法来取消对应控件对鼠标的捕获。

