# 服务拆分带来的问题

- 运维的新挑战：在微服务架构中，运维人员需要维护的进程数量会大大增加
- 接口的一致性：虽然我们拆分了服务，但是业务逻辑上的依赖并不会消除，只是从单体应用中的代码依赖变为了服务间的通信依赖。而当我们对原有接口进行了一些修改，那么交互方也需要协调这样的改变来进行发布，以保证接口的正确调用。我们需要更完善的接口和版本管理，或是严格地遵循开闭原则。、
- 分布式的复杂性：由于拆分后的各个微服务都是独立部署并运行在各自的进程内，它们只能通过通信来进行协作，所以分布式环境的问题都将是微服务架构系统设计时需要考虑的重要因素，比如**网络延迟、分布式事务、异步消息**等。

# 微服务的九大特性

1. **服务组件化**：组件，是一个可以独立更换和升级的单元。就像电脑中的 CPU，内存和硬盘一样，可以独立的升级和更换而不影响其他的部分。每一个服务都独立开发、部署，可以有效避免一个服务的修改引起整个系统的重新部署

2. **按业务组织团队**：由于每一个微服务都是针对特定业务的宽栈或是全栈实现，既要负责数据的持久化存储，又要负责用户的接口定义等各种跨专业领域的职能。因此，面对大型项目的时候，对于微服务团队的拆分更加建议按业务线的方式进行拆分，一方面可以有效减少服务内部修改所产生的内耗；另一方面，团队边界可以变得更为清晰。

3. **做产品的态度**：我们需要用做“产品”的态度来对待每一个微服务，持续关注服务的运作情况，并不断分析以帮助用户来改善业务功能

4. **智能端点与哑管道**：在单体应用中，组件间直接通过函数调用的方式进行交互协作。而在微服务架构中，由于服务不在一个进程中，组件间的通信模式发生了改变，若仅仅将原本在进程内的方法调用改成 RPC 方式的调用，会导致微服务之间产生烦琐的通信，使得系统表现更为糟糕，所以，我们需要更粗粒度的通信协议。在微服务架构中，通常会使用以下两种服务调用方式：

   1. 使用 HTTP 的 RESTful API 或轻量级的消息发送协议，实现信息传递与服务调用的触发。

   2. 通过在轻量级消息总线上传递消息，类似 RabbitMQ 等一些提供可靠异步交换的中间件。

   在极度强调性能的情况下，有些团队会使用二进制的消息发送协议

5. **去中心化治理**：在实施微服务架构时，通过采用轻量级的契约定义接口，使得我们对于服务本身的具体技术平台不再那么敏感，这样整个微服务架构系统中的*各个组件就能针对其不同的业务特点选择不同的技术平台*，

6. **去中心化管理数据**：我们在实施微服务架构时，都希望让每一个服务来管理其自有的数据库。虽然数据管理的去中心化可以让数据管理更加细致化，通过采用 

   更合适的技术可让数据存储和性能达到最优。但是，由于数据存储于不同的数据库实例中后，*数据一致性也成为微服务架构中亟待解决的问题之一*。分布式事务本身的实现难度就非常大，所以在微服务架构中，我们更强调在各服务之间进行“无事务”的调用，*而对于数据一致性，只要求数据在最后的处理状态是一致的即可*，若在过程中发现错误，通过补偿机制来进行处理，使得错误数据能够达到最终的一致性
   
7. **基础设置自动化**：在微服务架构中，务必从一开始就构建起“持续交付”平台来支撑整个实施过程，该平台需要两大内容，缺一不可：

   - 自动化测试：每次部署前的强心剂，尽可能地获得对正在运行的软件的信心。

   - 自动化部署：解放烦琐枯燥的重复操作以及对多环境的配置管理

8. **容错设计**：在微服务中会出现故障的蔓延,例如调用顺序为： C->B->A，如果服务 A 出现故障，这 B 调用 A 服务的线程会挂起，此时如果有大量的 C 请求，则会导致 B 服务的线程出现大量挂起的现象，最后导致 A 服务也不能够正常工作。所以，在微服务架构中，快速检测出故障源并尽可能地自动恢复服务是必须被设计和考虑的。通常，我们都希望*在每个服务中实现监控和日志记录的组件*，比如服务状态、断路器状态、吞吐量、网络延迟等关键数据的仪表盘等。

9. **演进式设计**：随着系统的发展或者业务的需要，架构师会将一些经常变动或是有一定时间效应的内容进行微服务处理，并逐渐将原来在单体系统中多变的模块逐步拆分出来，而稳定不太变化的模块就形成一个核心微服务存在于整个架构之中。

# SpringCloud 简介

Spring Cloud是一个基于Spring Boot实现的微服务架构开发工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。

## Spring Cloud 组件

- Spring Cloud Config：配置管理工具，支持使用 Git 存储配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新、加密/解密配置内容等。

- Spring Cloud Netflix：核心组件，对多个 Netflix OSS 开源套件进行整合。

- Eureka：服务治理组件，包含服务注册中心、服务注册与发现机制的实现。
- Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。
- Ribbon：客户端负载均衡的服务调用组件。
- Feign：基于Ribbon和Hystrix的声明式服务调用组件。
- Zuul：网关组件，提供智能路由、访问过滤等功能。
- Archaius：外部化配置组件。
- Spring Cloud Bus：事件、消息总线，用于传播集群中的状态变化或事件，以触发后续的处理，比如用来动态刷新配置等。
- Spring Cloud Cluster：针对 ZooKeeper、Redis、Hazelcast、Consul的选举算法和通用状态模式的实现。
- Spring Cloud Cloudfoundry：与Pivotal Cloudfoundry的整合支持。
- Spring Cloud Consul：服务发现与配置管理工具。
- Spring Cloud Stream：通过Redis、Rabbit或者Kafka实现的消费微服务，可以通过简单的声明式模型来发送和接收消息。
- Spring Cloud AWS：用于简化整合Amazon Web Service的组件。
- Spring Cloud Security：安全工具包，提供在 Zuul 代理中对 OAuth2 客户端请求的中继器。
- Spring Cloud Sleuth：Spring Cloud应用的分布式跟踪实现，可以完美整合 Zipkin。 
- Spring Cloud ZooKeeper：基于 ZooKeeper 的服务发现与配置管理组件。
- Spring Cloud Starters：Spring Cloud的基础组件，它是基于 SpringBoot 风格项目的基础依赖模块。
- Spring Cloud CLI：用于在 Groovy 中快速创建 Spring Cloud 应用的 Spring Boot CLI 插件。
- ......

# Actuator 监控与管理

spring-boot-starter-actuator 模块能够自动为 Spring Boot 构建的应用提供一系列用于监控的端点。spring-boot-starter-actuator 模块的实现对于实施微服务的中小团队来说，可以有效地省去或大大减少监控系统在采集应用指标时的开发量

## 端点

spring-boot-starter-actuator 模块中已经实现的一些原生端点。根据端点的作用，可以将原生端点分为以下三大类：

- 应用配置类：获取应用程序中加载的应用配置、环境变量、自动化配置报告等与 Spring Boot 应用密切相关的配置类信息。

- 度量指标类：获取应用程序运行过程中用于监控的度量指标，比如内存信息、线程池信息、HTTP请求统计等。
- 操作控制类：提供了对应用的关闭等操作类功能。

### 应用配置类

由于 Spring Boo为了改善传统 Spring 应用繁杂的配置内容，采用了包扫描和自动化配置的机制来加载原本集中于 XML 文件中的各项内容。虽然这样的做法让我们的代码变得非常简洁，但是整个应用的实例创建和依赖关系等信息都被离散到了各个配置类的注解上，这使我们分析整个应用中资源和实例的各种关系变得非常困难。而这类端点可以帮助我们轻松获取一系列关于 Spring 应用配置内容的详细报告，比如自动化配置的报告、Bean 创建的报告、环境属性的报告等。

- `/autoconfig`： 该端点用来获取应用自动化配置的报告，其中包括所有自动化配置的候选项。同时还列出了每个候选项是否满足自动化配置的各个先决条件
- `/beans`：该端点用来获取应用上下文中创建的所有 Bean
- `/configprops`：该端点用来获取应用中配置的属性信息报告。
- `/env`：该端点与 `/configprops` 不同，它用来获取应用所有可用的环境属性报告。包括环境变量、JVM 属性、应用的配置属性、命令行中的参数。通过该端点并配合 @ConfigurationProperties 注解可以将不容易发现的属性引入到我们的应用程序中来进行使用
- `/mapping`：该端点用来返回所有 Spring MVC 的控制器映射关系报告
- `/info`：该端点用来返回一些应用自定义的信息。默认情况下，该端点只会返回一个空的 JSON 内容。我们可以在 application.properties 配置文件中通过 info 前缀来设置一些属性

### 度量指标类

应用配置类获取的信息可以说是一个静态报告。而度量指标类端点提供的报告内容则是*动态变化*的，这些端点提供了应用程序在运行过程中的一些快照信息，比如内存使用情况、HTTP请求统计、外部资源指标等。

- `/metrics`：该端点用来返回当前应用的各类重要度量指标，比如内存信息、线程信息、垃圾回收信息等。对于 `gauge.*` 和 `counter.* ` 的统计，这里有一个特殊的内容请求 star-star，它代表了对静态资源的访问。这两类度量指标非常有用，我们不仅可以使用它默认的统计指标，还可以在程序中轻松地增加自定义统计值。只需要通过注入 org.springframework.boot.actuate.metrics.CounterService 和 org.springframework.boot.actuate.metrics.GaugeService 来实现自定义的统计指标信息。比如我们可以像下面这样自定义实现对hello接口的访问次数统计。我们还可以通过 `/metrics/{name}` 接口来更细粒度地获取度量信息，比如可以通过访问 `/metrics/mem.free` 来获取当前可用内存数量。

- `/health`：该端点在一开始的示例中我们已经使用过了，它用来获取应用的各类健康指标信息。在 spring-boot-starter-actuator 模块中自带实现了一些常用资源的健康指标检测器。这些检测器都通过 HealthIndicator 接口实现，并且会根据依赖关系的引入实现自动化装配，比如下面列出的这些。

  | 检测器                    | 功能                       |
  | ------------------------- | -------------------------- |
  | DiskSpaceHealthIndicator  | 低磁盘空间检测             |
  | DataSourceHealthIndicator | 检测 DataSource 是否可用   |
  | MongoHealthIndicator      | 检测 Mongo 数据库是否可用  |
  | RabbitHealthIndicator     | 检测 Rabbit 服务器是否可用 |
  | RedisHealthIndicator      | 检测 Redis 服务器是否可用  |
  | SolrHealthIndicator       | 检测 Solr 服务器是否可用   |

- `/dump`：该端点用来暴露程序运行中的线程信息。它使用 java.lang.management.ThreadMXBean 的 dumpAllThreads 方法来返回所有含有同步信息的活动线程详情。

- /trace：该端点用来返回基本的 HTTP 跟踪信息。默认情况下，跟踪信息的存储采用org.springframework.boot.actuate.trace.InMemoryTraceRepository 实现的内存方式，始终保留最近的 100 条请求记录

### 操作控制类

操作控制类端点拥有更强大的控制能力，如果要使用它们的话，需要通过属性来配置开启操作。在原生端点中，只提供了一个用来关闭应用的端点：`/shutdown`

```yaml
endpoints:
	shutdown:
		enabled: true
```

## 服务治理

服务治理可以说是微服务架构中最为核心和基础的模块，**它主要用来实现各个微服务实例的自动化注册与发现**

### 服务注册 

1. 在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单

2. 服务注册中心还需要以心跳的方式去监测清单中的服务是否可用，若不可用需要从服务清单中剔除，达到排除故障服务的效果

### 服务发现

由于在服务治理框架下运作，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务名发起请求调用实现。所以，服务调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置。因此，调用方需要向服务注册中心咨询服务，并获取所有服务的实例清单，以实现对具体服务实例的访问。

### Netflix Eurka

Spring Cloud Eureka，使用 Netflix Eureka 来实现服务注册与发现，它既包含了服务端组件，也包含了客户端组件，并且服务端与客户端均采用 Jav编写，所以 Eurek主要适用于通过 Java 实现的分布式系统，或是与 JVM 兼容语言构建的系统。但是，由于 Eureka 服务端的服务治理机制提供了完备的RESTful API，所以它也支持将非 Java 语言构建的微服务应用纳入 Eureka 的服务治理体系中来。只是在使用其他语言平台的时候，需要自己来实现 Eureka 的客户端程序。

Eureka 服务端依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。如果 Eureka 以集群模式部署，当集群中有分片出现故障时，那么 Eureka 就转入自我保护模式。*它允许在分片故障期间继续提供服务的发现和注册*，当故障分片恢复运行时，集群中的其他分片会把它们的状态再次同步回来

Eureka 客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka 客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。

在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需在 application.properties 中增加如下配置：

```properties
server:
  port: 9000
spring:
  application:
    name: eureka-server
eureka:
  instance:
    hostname: localhost
    prefer-ip-address: true # 将 Hostname 替换成 IP 地址，在 Eureka 客户端中设置
  client:
    service-url:
      defaultZone: http://localhost:9000/eureka # 设置服务注册中心的地址
    register-with-eureka: false # 不向 Eureka 注册自己
    fetch-registry: false # 不向 Eureka Server 获取服务列表
```

#### 高可用注册中心

Eureka Server 的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果