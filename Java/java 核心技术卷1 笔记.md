# java 核心技术卷 I 笔记

java 的编译器将 java 源码编译成与计算机体系结构无关的字节码，字节码。

解释虚拟机的指令肯定是比全速运行机器指令要慢的多，但是 JVM 有一个选项能够，可以将执行频繁的字节码翻译成机器码，这一个过程称为即时编译。JVM 可以检测指令序列的行为，从而增强它的安全性

字节码可以动态的(在运行时)翻译成对应 CPU 执行的机器码



即时编译器可以监测频繁执行的代码并优化这些代码从而提高运行速度，更为复杂的优化就是消除函数调用(**内联**？)，即时编译器知道哪些类已经加载了，基于当前加载的类，如果特定的函数不会被覆盖，就可以使用内联，必要时，还可以撤销优化

java 相较于 C 或者 C++ 更具有动态性， 它能不断地适应变化的环境。java 库中可以自由添加新方法和实例变量，而对客户端没有任何影响。**当需要将某些代码添加到正在运行的程序中时，动态性将是一个非常重要的特性**

JRE：java 运行环境，它包含虚拟机，但是不包含编译器



java 中有一个可以表示任意精度的算数包，通常称为“big number”， 它是一个新的类，不是一个基本数据类型

在 java 中，整型的范围与运行 java 代按摩的机器无关

从 java 7 开始，可以在数字中加入下划线，这样跟容易阅读代码，java 编译器在编译时，会去掉这些下划线。如 0b1111_0100_0000

java 中没有无符号的整型，全是有符号的整型数据



一个正整数除以 0， 得到的结果是正无穷大。计算 0 / 0 或者 负数的平方根，得到的结果是 NaN( Not a Number), NaN 和 NaN 比较永远是不相等的。

浮点数不适合于无法接受舍入误差的金融计算中，例如 `System.out.println(2.0 - 1.1)`，得到的结果不是 0.9， 而是打印出：0.89999999999..

出现这个的原因是浮点数采用二进制表示，而在二进制中无法精确的表示分数 1/10



**注意：**Unicode 转义序列会在解析代码之前得到处理，例如：`"\u0022+\u0022"` ，由于在解析之前处理，所以它相当于：`""+""`，也就是空字符串。因此注释中的转移字符也要非常小心，如 `// \u00A0 is a new line` 这里的转义字符`\u00A0` 会被解析成一个换行符

整数除 0 会产生异常，而浮点数除 0 将会得到无穷大或或者 NaN 的结果



不建议在表达式中使用自增(++)或自减(--)运算符，如果单独的在一行对变量使用是可以的，不建议和其他的运算混合在一起使用，不易于阅读代码



**注意：** 移位运算符的右操作数在编译时，会进行模 32 的运算，即：`1 << 35` 相当于：`1 << 3`



java 中的 String 类对象是不可变的，即 java 中的字符串是不可变字符串，但是字符串可以被共享。字符串的共享可以认为是 JVM 将字符串放在了一个公共区域，创建一个字符串时，就将字符串放入公共区域，并将变量的值指向字符串所在的区域。如果要实现对字符串的复制，则直接让另一个变量指向对应字符串所在的位置即可，同时 java 的字符串存放在堆中， **且只有字符串常量才会被共享，而 String 类对象是不会别共享的**。

注意：判断两个字符串的字面量是否相等时，需要使用`equals(Stirng str)`方法，不能够使用 `==` 判断两个字符串的字面量是否相等，因为这个运算符比较的是这两个字符串的引用是否相等



StringBuilder 不是线程安全的，在单线程的环境可以安全的使用，且执行效率会比 StringBuffer 高， StringBuffer 是线程安全的，当多个线程对同一个 String 进行操作时，需要使用 StringBuffer 



嵌套的两个块级作用域中不能够声明相同的变量

```java
{
	int n;
    ....
    {
        int k;
        int n; // 这是错误的，编译不能够通过 error -- can't redefine in inner block
    }
}
```



**注意：** 循环条件中如果判断两个浮点数是否相等可能会出现不符合你预期的情况，因为 0.1 用二进制无法精确的表示，精度的误差使得变量晕眩之后可能用于都不可能等于某个数，例如

```java
for(double i = 1.0, i != 10.0; i+=0.1){
	....
}
```

这将会是一个死循环	



switch 中 case 允许的类型：char byte short 或 int 的常量表达式，枚举常量，从 java 7 开始，支持字符串常量, long 类型都是不支持的



在 java 中第一个命令行参数不是程序名，即 args[0] 不是程序名，而是命令行中传递的第一个参数



java 中没有真正的多维数组，java 中的多维数组是数组中的数组，并且 java 中一维数组中存储的是其他数组的引用，因此，可以多维数组可以是不规则的



所有的 java 对象都保存在堆中



在类声明的方法中，它的返回值最好不要是类属性的引用，因为这样破坏了封装性的特点，如果将某个属性的引用返回，则可以在外面进行修改，从而类中不可以修改的数据变的可以修改了，如果一定要返回一个属性的引用，可以返回一个克隆之后的对象，而不是直接返回



如果类中的某个字段必须初始化，可以使用 final 关键字进行修饰，即构造器执行之后，该字段必须被初始化



java 中参数的值是传递的值的一个拷贝，对于非引用性变量来说，传递之后对变量的修改不会影响传递给它值的变量的值。而引用型变量则是会受到影响。因为引用型变量中存储的是对象的一个引用。



只有在类没有声明任何构造方法的情况下，系统才会提供一个无参构造方法，其他情况下都不会提供。



类方法中的 this 关键字是一个隐式参数，可以使用 this 关键字在构造方法中调用其他的构造方法，this 指代的就是实例化对象本身



在创建对象时，初始化代码块(直接用大括号括起来的部分)先执行，然后在执行构造方法



创建对象的步骤：

1. 将所有的字段进行默认的初始化
2. 按照在类中出现的顺序执行初始化语句和初始化代码块
3. 执行对应的构造方法



静态初始化代码块只会在类第一次加载的时候执行一次，之后再初始化任何对象都不会在执行该代码块



我们可以为任何一个类添加 finalize 方法，finalize 方法会在垃圾回收器清除对象之前调用。**但是在实际应用中，不要依赖于 finalize 方法回收任何稀缺的资源，因为你不知道 finalize 方法什么时候会被调用，它的调用完全取决于垃圾回收器，所以不建议使用**

其中有一个替代的方法就是：使用 Runtime.addShutdownHook() 添加 shutdown hook, 在某个资源使用完毕后需要立即释放，就需要人来进行管理，对象用完时，可以使用一个 close 方法来完成相应的清理工作。



导入静态方法和静态字段可以使用 import static .... 的方式，但是似乎不是很常用，也不推荐使用， 因为这样会让代码不易于阅读



如果没有在一个 java 文件中声明 package 语句，那么这个文件就会被放置在一个默认的包中，默认的包是一个没有名字的包



声明为 public 的类可以被当前包和其他包中的类使用，声明为 private 的类，只能够被当前类使用，如果没有指定 public 或者 private 那么这个类就只能被类所属的包中的其他类所使用



用户自定义的包，不能以 java. 开始



jar 包使用 zip 格式组织文件和子目录，因此可以使用实现了 zip 程序程序的软件查看 jar 包中的内容



javac 编译器总是在当前目录中查找文件，而 JVM 只在类路径中有 “.” 目录的时候才查看当前目录。如果没有设置类路径页没关系，并不会产生什么问题，默认的类路径就是包含 ”.” 的目录。如果设置了类路径却忘记了包含 “.” 的目录，则程序仍然可以通过编译，但是不能够运行



JVM 查找类的过程：

1. 首先查找类路径下的系统类文件：jre/lib 和 jre/lib/ext 下的类文件
2. 找不到时，再查看类路径，从类路径声明的目录下去查找

javac 编译文件的过程：

1. javac 编译某个文件时，如果发现使用了其他的类，那么就会在 import 语句指定的包下去查找
2. 如果找到了两个以上的类，就会产生编译错误
3. 找到文件后，如果源文件比类文件新，就需要将源文件重新编译
4. 如果在类中导入一个没有权限申明的类，javac 编译器则需要在该类所属包中的所有类中搜索对应的类



javadoc 命令抽取的信息：

- 包
- 公有类和接口
- 公有的和受保护的方法和构造方法
- 公有的和受保护的属性(字段)



反射是指在程序运行期间发现更多的类及其属性的能力



有些人认为 super 和 this 关键有着类似的概念，实际上，这样比喻不是很恰当，因为 super 关键字不是一个引用，不能够将 super 赋值给另一个变量，它的作用就是告诉编译器调用父类对应的方法或者属性



子类调用父类的构造方法必须是子类构造方法中的第一句代码。如果子类没有显示的调用父类的构造方法，在创建对象时，就会自动调用父类中的无参构造方法。如果父类没有无参构造方法，而在子类中又没有显示的调用父类的有参构造方法，java 的编译器就会报错



如果某个示例对象调用一个方法，而该方法父类和子类都有时，调用的是父类的方法还是子类的方法呢？答案是由其引用的对象来决定，如果引用的是父类，则使用的父类的方法，如果引用的是子类，则使用的是子类的方法。当引用的对象中没有对应的方法时，才会向上(父类)去查找对应的方法。每次程序运行都要进行搜索，着非常的麻烦，因此虚拟机会为每一个类创建一个方法表，其中列出了所有的方法签名和实际调用的方法。如果在代码中使用 super 关键字调用方法，JVM 则会去查找父类的方法表



在运行时能够自动地选择哪个方法的现象称为动态绑定



如果是 private, static, final 修饰的方法或者是构造器，编译器能够准确的知道应该调用哪个方法，我们称这种方式为静态绑定。

其他关键字修饰的方法采用动态绑定的方式进行调用



方法的名字和参数列表称为方法的签名，但返回值的类型不是方法签名的一部分



在覆盖一个方法时。子类方法的可见性不能够低于父类方法的可见性，例如父类方法是 public， 则子类方法就只能够是 public



将一个类声明为 final，则类中对应的方法都会被 final 修饰，但是类中的属性不会被 final 字段修饰



如果一个方法没有被覆盖，而且很短，编译器就能够对其进行优化，这个过程就称为内联(inlining)。例如内联调用 e.getName() 将会被替换成 e.name。这个优化很有意义，因为 CPU 再执行调用方法的指令时，使用的分支转移指令会扰乱预取指令的策略。如果 getName() 被覆盖了就不会做这种优化



private => 仅对本类可见

public => 对所有类可见

protected => 对本包及子类可见

default => 对本包可见



如果重新定义 equals 方法，就得重新定义 hashCode 方法，以便用户可以将对象插入到散列表中



当一个对象是用 + 号和其他字符串连接在一起时，java 的编译器会自动调用对象的 toString 方法



ArrayList 的容量与数组的大小有着重要的区别，如果声明一个 100 容量的数组，那么就会给他分配 100 个空间用于存放数组

而声明一个 100 容量的 ArrayList 则是表明它有存放 100 元素的潜力，但是在创建时，并没有给其分配空间，它的空间分配是根据它具体存放了多少数据，根据扩容规则具体进行分配的。



java 中的泛型不允许是基本的数据类型，但是可以使用基本数据类型的包装类



自动装箱的规范要求



拆箱和装箱是编译器实现的，虚拟机只是负责执行相应的字节码



一个方法的参数是可变参数，如果在调用该方法时，想要传递一个数组， 那么传递的这个数组必须是传递的参数中的最后一个



能够分析类能力的程序称为反射(reflective)



使用反射获得方法指针的代码要比直接调用方法明显的慢一些，因此，建议只在必要的时候才使用 Method 对象，取而代之的是使用接口以及 java SE8 中的 lambda 表达式。特别建议 java 开发者不要使用 Method 对象的回调功能，使用接口回调会使代码的执行速度更快，更易于维护



要让一个类使用 Arrays 的 sort 方法，必须实现 Comaprable 接口，该接口只需要实现一个方法： compareTo(Object obj)。值得注意的是：实现该接口的compareTo()方法时，它的返回值如果是根据浮点数的比较进行返回的需要注意，因为浮点数精度的问题，可能两个浮点数不相等，但是比较之后返回值为 0. 因此如果需要在实现该接口时，需要返回浮点数的比较结果，可以使用 `Double.compare(x, y)` 这个方法， 当 x < y 时，返回 -1， 当 x > y 是返回 1ddd



接口中的方法自动的设置为了 public， 接口中的属性自动设置为：public static final



接口中的默认方法，必须使用 default 关键字进行修饰，默认方法的出现为了解决代码重复的问题，假设一个类实现了一个接口，这个接口定义了很多方法，但是这个类只需要这个接口中的某一个方法，此时如果没有默认方法，那么这个类就需要实现接口中所有的方法，即使是那些这个类不关心的方法也需要进行空实现，这就很影响代码的阅读性，同时也会有很多的冗余代码。如果接口中有默认的方法，那么程序员只需要挑选自己想实现的方法就行，其余的方法继承接口中默认实现的方法就好。

默认方法的另外一个好处就是方便对接口进行扩展。如果没有默认方法，那么在对接口扩展时，那些实现了该接口的类就需要再实现接口中新增的方法，这就需要动以前的代码，而程序有一个原则就是在对程序进行扩展时，不需要动之前写过的代码。 如果在接口中添加一个默认的方法，则不需要动以前代码，又能够对原有的接口进行扩展，添加新的功能



如果超类或者接口中实现的冲突了怎么解决？

1. 超类优先，如果超猎提供了一个具体的方法，那么接口中同名且有相同的参数类型的默认方法会被忽略
2. 接口冲突，如果一个超接口提供了一个默认方法， 另一个接口提供了一个同名且参数类型相同的方法，则必须通过覆盖的方式来解决冲突
3. 如果实现了两个接口，这两个接口中含有相同的方法，一个接口提供了默认实现，一个接口没有提供默认实现，此时程序员就必须手动的来解决这种二义性(手动的实现同名的方法)



lambda 表达式：参数、箭头(->)、表达式，如果一个语句不能够完成需求，则需要将多个语句放入到大括号中，并且需要显示的声明 return 语句。即使 lambda 表达式没有参数，括号也不能够省略。如果可以推导出表达式参数的类型，则参数的类型可以不写，直接填写变量名即可。如果只有一个参数且参数类型可以推导出来，那么可以省略小括号。如果 lambda 表达式只在特定的分支返回数据，而其他的分支不返回数据，这是错误的，编译器会报错。对于一个已经存在的方法，我们只需要传递方法名即可，使用 `::` 将类名和方法名分隔开，例如`System.out::println`, `this::yourfunc`, `supper::func` 等。在没有 return 语句时，语句的执行结果就是返回值。



接口中只有一个方法的接口称为函数式接口，这种接口可以使用 lambda 表达式进行实现



构造器的引用：`ClassName:: new`, 至于使用类的哪一个构造方法则取决于上下文，即编译器会根据传递过来的参数类型去匹配对应的构造方法



`int[]::new` 相当于 `x -> new int[x]`                               



lambda 表达式由三个部分组成：

- 代码块
- 参数
- 自由变量：指的是非 lambda 表达式定义的参数以及非代码块中定义的变量，即在函数中嵌套 lambda 表达式时，lambda 表达式使用的外层函数中的那些变量就是自由变量

java 中对于 lambda 表达式使用自由变量有一个要求：只能读，不能够改，否则会报错；或者引用的自由变量在外部可能发生变化也会报错。这个限制主要是并发执行时不安全

其中有一条规则是：lambda 表达式捕获的变量实际上是不可变的(final)，即初始化后就不再改变

其实 代码块+自由变量 组成了所谓的闭包

lambda 表达式中变量的作用域规则和嵌套块的变量作用域规则相同，不能够和外部作用域出现同名的变量

lambda 表达式中的 this 关键字指的是创建 lambda 表达式方法中的那个隐式参数 this

使用 lambda 表达式的一个重点就是延迟执行(deferred execution)



内部类中使用外部类的数据需要使用：`outer`， 即 `outer.<prop>`, 其中 outer 在大部分情况下可以省略。当内部类没有声明构造方法时，编译器会自动生成一个默认的构造方法：

```java
public <ClassName>(<OuterClass> outerName){
    outer = outerName
}
```

内部类中声明的所有静态属性都必须是 final。原因是：我们希望静态属性只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例，如果静态域不是 final 的，它可能就不是唯一的。

内部类中不能够定义 static 方法



局部内部类：在类定义的方法中定义的类。局部内部类不能够使用 public 或者 private 修饰符进行修饰，它的作用域被限定在方法的作用中。局部内部类有一个优势就是：它对外部是完全隐藏的，除了它所在的方法知道外，其他地方的代码都不知道它的存在；它不仅能够访问它的外部类，还可以访问局部变量，但是局部变量必须被 final 关键字修饰，即被引用的局部变量一经赋值，就不能够在发生改变



利用代理可以在运行时创建一个实现了一组给定接口的新类。这个功能只有在编译时无法确定需要实现哪个接口时才有必要。



在使用 object 类的 clone 方法，是浅拷贝，不是深拷贝，如果对象中含有其他对象的引用，那么拷贝的只是引用罢了，并没有将引用的对象也拷贝一份。

要实现深拷贝需要考虑以下几点：

- 默认的 clone 方法是否满足要求
- 可变的子对象上是否可以调用 clone 方法
- 该不该使用 clone 方法，如果要能够使用 clone 方法， 那么对应的对象就必须实现 cloneable 接口



标记接口：它的作用就是确保一个类实现一个或一组特定的方法, 标记接口不包含任何的方法，它唯一的作用就是允许在类型查询中使用 instanceOf 方法, 建议自己的程序中不要使用标记接口



在静态类不需要访问外围类对象的时候，应该使用静态内部类; 与常规内部类不同，静态内部类可以有静态属性和静态方法;声明在接口中的内部类自动成为 static 和 public 类



如果子类中覆盖了超类中的一个方法，子类方法中声明的异常不能够比超类方法中声明的异常的范围更广。如果超类方法没有抛出任何异常，那么子类方法也不能抛出任何异常

如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行

finally 语句块中的语句无论是否发生异常，都会被执行。通常 finally 语句用于关闭资源,强烈建议 try/finally 的语句块,同时建议将 try/finally 语句块放入 try/catch 语句块中，这样在 finally 语句块中发生的错误，可以被捕获到

```java
try{
    try{
        // code that might throw exception
        ....
    }finally{
        in.close()
    }
}catch(IOException e){
    // show error message
}
```

即使在 try 语句块中包含 return 语句，finally 语句块中的语句仍然会被执行。此时如果 finally 语句块中也有一个 return 语句，则 finally 语句块中的 return 语句会覆盖 try 语句块中的 return 语句

带资源的 try 语句，会自动调用资源的 close 方法,无论是否发生异常都会调用资源的 close 方法，功能类似于 finally 语句块

```java
try(Scanner in = new Scanner(new FileInputStream("/usr/share/dict/words")), "UTF-8"){
    while(in.hasNext()){
        System.out.println(in.next());
    }
}
```

能使用这个语句的类需要实现 AutoCloseable 接口或者其子接口,接口中包含了一个方法：close 方法



