# B+ 树的特点

在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度

B+ 树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。

B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快

B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

# Mysql 调优

![img](../Attachment/008i3skNgy1gtzx3bvkbkj61c40bsq5o02.jpg)

理论上来说，如果表有一定的数据量，那就应该要创建对应的索引

1. 是否能使用「覆盖索引」，减少「回表」所消耗的时间。意味着，我们在 select 的时候，一定要指明查询的列，而不是 `select *`

2. 考虑是否组建「联合索引」，如果组建「联合索引」，尽量将区分度最高的放在最左边，并且需要考虑「最左匹配原则」

3. 对索引进行函数操作或者表达式计算会导致索引失效
4. 利用子查询优化超多分页场景。比如 `limit offset, n` 在 MySQL 是先获取 `offset + n` 条记录，再返回 n条记录。而利用子查询则是查出 n 条，通过 ID 检索对应的记录出来，提高查询效率。
5. 通过 explain 命令来查看 SQL 的执行计划，看看自己写的 SQL 是否走了索引，走了什么索引。通过 show profile 来查看 SQL 对系统资源的损耗情况（不过一般还是比较少用到的）
6. 在开启事务后，在事务内尽可能只操作数据库，并有意识地减少锁的持有时间（比如在事务内 需要插入 && 修改数据，那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放）

# 建立索引指导原则

1. 越小的数据类型越好。
2. 简单的数据类型越好，给日期做索引的使用 datetime 。
3. 尽量避免使用 NULL,指定列为 not null 有空值的列很难进行查询优化。可以使用 0 或者一个特殊的值或者空字符串来代替。 
4. 为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
5. 非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。
6. 在使用 InnoDB 存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。

# Mysql 锁

## 锁的类型

- 乐观锁
- 悲观锁
  - 共享锁(读锁): 如果事务对读锁进行修改操作，很可能会造成死锁(当读锁没有释放，而其他的请求进行修改操作，此时请求修改的操作会被阻塞),在 mysql 的 SQL 中使用 `LOCK IN SHARE MODE` 可以获取共享锁
  - 排它锁(写锁): 当一个事务对数据行加上了排它锁，那么只有当前的事务可以对锁住的数据行进行读写操作，其他的事务不能够对其加任何的锁，同时 **排它锁会阻塞所有的排它锁和共享锁**
- 行锁: 多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
- 间隙锁：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。InnoDB使用间隙锁的目的，一方面是为了防止幻读，另外一方面，是为了满足其恢复和复制的需要。如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！

对于 update,insert,delete 语句会自动加排它锁的原因

当执行批量修改数据脚本的时候，行锁升级为表锁。其他对订单的操作都处于等待中

原因：**innoDB 只有在通过索引条件检索数据时使用行级锁，否则使用表锁！**

**InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。**

**行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。**

# 参考文献

- [MySQL索引原理，一篇从头到尾讲清楚](https://juejin.cn/post/6931901822231642125)