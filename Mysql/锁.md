# 全局锁

## 如何使用全局锁

要使用全局锁可以使用如下命令：

```sql
flush tables with read lock;
```

执行后，**整个数据库就处于只读状态了**，这时其他线程执行以下操作，都会被阻塞：

- 对数据的增删改操作，比如 insert、delete、update 等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。

如果要释放全局锁，则要执行这条命令：

```sql
unlock tables
```

当然，当会话断开了，全局锁会被自动释放。

## 全局锁的应用场景是什么？

全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

## 如何在备份数据期间避免业务停滞

如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

```ad-info
title:提示

备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。
```

InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。

但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。

# 元数据锁

元数据锁 MDL(Metadata Lock) 主要用于维护表元数据的一致性，保证当用户对表执行 CRUD 操作时，防止其他线程对表结构进行变更。该锁不需要我们显示的去使用，因为我们在对数据库表进行操作的时候，会自动为表加上 MDL:

- 对一张表进行 CRUD 操作，加上 MDL 读锁
- 修改表结构的操作，加上 MDL 写锁

并且 MDL 写锁的优先级高于 MDL 读锁。

如果线程 A 在执行 select 语句期间（加 MDL 读锁)，线程 B 试图修改表的结构(加 MDL 写锁)，此时线程 B 会阻塞，直到线程 A 查询完毕（释放 MDL 读锁)

如果线程 B 在修改表结构期间(加 MDL 写锁)，线程 A 执行 Select 语句(加 MDL 读锁)，那么线程 A 阻塞，知道线程 B 执行执行完毕(释放 MDL 写锁)

## 元数据所何时释放

MDL 锁会在事务提交之后释放，也就是说在事务执行期间，是一直持有 MDL 锁的。

由于 MDL 写锁的优先级是高于 MDL 读锁，如果写锁被阻塞，此时又有大量的 select 请求，那么线程很快就会被消耗殆尽。

所以为了安全的修改表的结构，在对表结构进行更改之前，先要看看数据库中是否有长事务已经加上了 MDL 读锁，如果有，则可以考虑 kill 掉该长事务，然后再执行表的变更操作。

# 意向锁

- 在 InnoDB 中，对表中的某行记录加上行级别的 **共享锁** 之前，需要在表级别上加上一个 **意向共享锁**
- 在 InnoDB 中，对表中的某行记录加上行级别的 **独占锁** 之前，需要在表级别上加上一个 **意向独占锁**

也就是说，执行 insert, update, delete 操作时，需要在表级别上加一个 **意向独占锁**，然后再对记录加上 **独占锁**

对于普通的 select 语句是不会加锁的，它通过 MVCC 实现读的一致性，是不用加锁的。

但是 select 语句也可以加上共享锁和独占锁：

```sql
// 先在表上加上意向共享锁，然后对读取的记录加上共享锁
select ... lock in share mode;

// 先在表上加上意向独占锁，然后再对读取的记录加上独占锁
select ... for update;
```

```ad-info
title: 总结

- 意向共享锁和意向独占锁是表级锁
- 意向共享锁和意向独占锁不会与行级别的共享锁和独占锁发生冲突
- 意向锁之间也不会发生冲突
- 意向锁只会与共享表锁(lock tables ... read)和独占表锁(lock tables ... write) 发生冲突
```

表锁和行锁都满足读读共享，读写互斥，写写互斥：

- 如果没有 意向锁，在加上 独占表锁 时，就需要遍历表中的所有记录，查看是否有记录加上了 独占锁，这样效率就非常的慢
- 有了意向锁之后，在对记录加上 独占锁 之前，会先对表加上 意向独占锁，那么在对表加上 独占表锁 时，只需要查看该表是否加上了 意向独占锁 即可，如果有，则表明表里有记录加上了独占锁，就不需要再去遍历表里的记录了

所以，意向锁的目的是为了快速判断表里是否有记录被加锁

# AUTO-INC 锁

AUTO-INC 锁主要用于主键自增的情形，用于保证主键的唯一性。

AUTO-INC 是一种特殊的表级别锁，它不会在事务提交之后在释放，而是在执行完插入语句之后就立即释放。

在插入数据时，会加上一个表级别的 AUTO-INC 锁，等插入语句执行成功之后，就会释放掉 AUTO-INC 锁。

一个事务在持有 AUTO-INC 锁的过程中，如果其他事务要向该表执行插入语句都会被阻塞，从而保证插入数据时，自增字段的值是连续递增的。

AUTO-INC 所的实现机制，导致 AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为其他事务中的插入会被阻塞。

因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增。

一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

- 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 innodb_autoinc_lock_mode = 1：
	- 普通 insert 语句，自增锁在申请之后就马上释放；
	- 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生**数据不一致的问题**。

![](../Attachment/Pasted%20image%2020230210144659.png)

session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后**两个 session 同时执行向表 t2 中插入数据**。

如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：

-   session B 先插入了两个记录，(1,1,1)、(2,2,2)；
-   然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；
-   之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。

可以看到，**session B 的 insert 语句，生成的 id 不连续**。

当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format=statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。

但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在**从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致**。

要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。

所以，**当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题**。

## 行级锁

行级锁的类型主要有三类：

- Record Lock，记录锁，也就是仅仅把一条记录锁上；
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

### Gap Lock

Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**

### Next-key Lock

Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中

**next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。

比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。

虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。

## 插入意向锁

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（_PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁_），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。

插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。

如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。

插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。