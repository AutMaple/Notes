解决慢查询最有效的方式就是尽心索引的优化，但是如何查看某条 sql 语句索引的使用情况呢？答案就是在 sql 语句前面加上 `explain` 关键字。

在 sql 语句前面加上 `explain` 关键字，可以查看 sql 语句的执行计划。通过执行计划，我们可以知道表的执行顺序，索引的使用情况，使用的索引的类型等。

索引优化的步骤：

1. 使用 explain 语句查看 sql 语句的执行计划
2. 判断哪些索引使用不当
3. 优化 sql。可能需要优化多次才能够达到最优的效果

## explain 的介绍

- explain 可以与 SELECT, INSERT, UPDATE, DELETE 和 REPLACE 语句一起使用
- 当 explain 与可解释的 sql 语句一起使用时，会展示对应 sql 语句详细的执行计划。包括如何连接表以及以何种顺序连接表等信息
- 当 explain 与非可解释的 sql 语句一起使用时，它将显示在命名连接中执行的语句的执行计划
- 对于 SELECT 语句，通过 SHOW WARNINGS 关键，explain 可以展示额外的执行信息。

### explain 的作用

1. 查看表的读取顺序
2. 查看哪些索引被使用
3. 表之间的引用
4. 每张表有多少行被物理查询

## explain 各字段介绍

| 字段          | 描述                   |
| ------------- | ---------------------- |
| id            | select 的查询序号      |
| select_type   | select 的类型          |
| table         | 查询的表名             |
| partitions    | 匹配的分区             |
| type          | 连接的类型             |
| possible_keys | 可能会使用到的索引     |
| key           | 实际使用的索引         |
| key_len       | 索引的长度             |
| ref           | 与索引比较的列         |
| rows          | 预计要检索的行数       |
| filtered      | 按表条件过滤的行百分比 |
| extra         | 额外信息               |

### id 列

id 列的值是 select 的序号，它决定了表的执行顺序

在执行计划中，id 值可能的情况：

1. id 值都相同
2. id 值都不相同
3. id 值既有相同又有不同

当 id 值都相同的时候，遵循从上到下的顺序执行

当 id 值不相同时，id 值大的先执行，小的后执行

当 id 值既有相同的，又有不同的时，id 值大的先执行，id 值相同的则遵循从上往下的顺序执行。

```ad-warning
title: 注意

id 列的值是可以为空，在 select_type 的类型是 `UNION RESULT` 的时候，id 列的值为空。 
```

### select_type 列

该列的可选值如下：

| 可选值               | 描述                                                |
| -------------------- | --------------------------------------------------- |
| SIMPLE               | 简单 SELECT                                         |
| PRIMARY              | 包含子查询时，PRIMARY 指代最外层 SELECT             |
| UNION                | UNION 关键字之后的查询语句                          |
| DEPENDENT UNION      | UNION 关键字之后的查询语句，取决于外部查询          |
| UNION RESULT         | UNION 的结果，通常和 UNION 一起出现                 |
| SUBQUERY             | 子查询，通常 WHERE 后面跟的查询语句为该类型的查询   |
| DEPENDENT SUBQUERY   | 子查询，取决于外部查询                              |
| DERIVED              | 派生表，通常 FROM 中出现的查询会被标记为 DERIVED    | 
| MATERIALIZED         | 物化子查询                                          |
| UNCACHEABLE SUBQUERY | 子查询，但是它的结果无法缓存                        |
| UNCACHEABLE UNION    | UNION 后的第二个或者更后面的 SELECT，其结果无法缓存 |

### table 列

表示使用到的表的名称，如 user，test 等，还有可能是 mysql 自动生成的表名：

- `UNION<M,N>`: 表示的是 id 为 M 和 id 为 N 的查询联合生成的表
- `derivedN`: 表示 id 为 N 的查询生成的派生表
- `subqueryN`: 表示 id 为 N 的查询生成的子查询表


### partition 列

partition 列显示的是分区表命中的分区情况。非分区表该字段为空(null)

### type 列

type 列表示连接的类型，该指标是查看索引执行情况的一个重要指标

type 列可选值如下：

| 可选值          | 描述                                                                                               |
| --------------- | -------------------------------------------------------------------------------------------------- |
| system          | 表只有一条记录                                                                                     |
| const           | 最多只有一行记录与之匹配，通过索引一次就能够找到。通常使用主键或者唯一索引作为查询条件时为该种类型 |
| eq_ref          | 多表查询时，主键或者唯一索引作为连接条件。前一个表中的行在当前表中只有一行记录与之对应             |
| ref             | 使用普通索引作为查询条件，查询结果可能有多个匹配的行                                               |
| fulltext        | 查询使用了全文索引                                                                                 |
| ref_or_null     | 类似 ref, 查询时还查询了值为 null 行                                                               |
| index_merge     | 多种索引合并的方式进行查询                                                                         |
| unique_subquery | 类似于 eq_ref, 在 IN 的子查询中使用了唯一索引                                                      |
| index_subquery  | 类似 unique_subquery, 在 IN 子查询中使用了普通索引                                                 |
| range           | 范围扫描, 如 between .. and 和 in 等                                                               |
| index           | 查询遍历了整棵索引树，与 `all` 类似，但是遍历的是索引，索引一般时在内存中，因此速度比 `all` 更快   | 
| all             | 全表扫描                                                                                           |

执行结果从上到下由好到坏

### possible_keys 列

表示可能会用到的索引

### Key 列

表示查询时真实使用的索引。改值可能为 `NULL`，当该为 `NULL` 时，有三种情况：

- 未使用索引: 有些查询不需要使用索引，如最大，最小值，因为 B+ 树本身是有序的。
- 未建立索引
- 索引失效：由于 sql 语句书写不当从而导致索引失效的情况

### key_len 列

表示索引占用的字节数

### ref 列

表示在查询索引时，哪些列或者常量被用来与索引的值进行比较

### rows 列

Mysql 估算出查询时，需要遍历的行数

### filtered 列

表示实际值与估算值之间的一个比值。如 `rows` 为 100， 而 `filtered` 为 50%，则表示实际查询出来的行数为 `100 * 50% = 50` 行。

### extra 列

该列包含查询时的一些额外信息

| 可选值                               | 描述                                                                                                                        |
| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------- |
| Using filesort                       | 在排序时使用了外部的索引排序，没有用到表内的索引进行排序(因为 mysql 没有找到排序字段的索引)                                                                    |
| Using temporary                      | mysql 需要创建临时表来存储查询结果。常见于 `order by` 和 `group by`                                                         |
| Using index                          | 表示查询使用了覆盖索引，不用回表，查询效率很高                                                                              |
| Using where                          | 表示查询使用了 where 字句进行条件过滤。一半在没有索引的情况下会出现                                                         |
| Imposible Where                      | 表示 where 字句的结果总是为 false 且无法查询到任何的数据                                                                    |
| Using join buffer(Block Nested Loop) | 连表查询的方法，表示当被驱动的表没有使用索引时，Mysql 会将驱动表读出来放到 `join buffer` 中，在遍历被驱动表与驱动表进行查询 | 
