# MySQL 一行记录是如何存放的

知道 MySQL 如何存储一行记录，就可以回答如下的面试题：

- MySQL 的 NULL 值会占用空间吗？
- MySQL 怎么知道 varchar(n) 实际占用的大小?
- varchar(n) 中 n 的最大值是多少?
- 行溢出后， MySQL 是怎么处理的?

## 表空间文件

`[tableName].ibd` 文件称为独占表空间文件。

### 表空间文件的结构

表空间由段(segment), 区(extent), 页(page), 行(row) 组成。InnoDB 存储引擎的逻辑存储结构大致如下图：

![](../Attachment/Pasted%20image%2020230203111655.png)

### 行(row)

数据库表中的记录都是按行进行存放的，每行记录根据不同的行格式，有不同的存储结构。

### 页(page)

记录是按照行存储的，但是数据的读取不是以行为单位进行读取的，否则一次 I/O 操作只能够读取一行数据，操作效率很低。因此 InnoDB 以页为单位来读写数据，也就是说，当需要读取一条记录时，InnoDb 会将记录所在的页整体加载进内存。

每个页默认的大小是 16KB，即连续的存储空间只有 16KB。

页是 InnoDB 存储引擎管理磁盘的最小单位，意味着数据库每次读写都是以 16KB 为单位。一次最少加载 16KB 内容到内存；一次最少 把 16KB 的内容从内存刷回磁盘。

页的类型有很多，常见的有数据页，undo 日志页，溢出页等等。数据表中的行记录是用 **数据页** 来管理的。 

### 区(extent)

我们知道 InnoDB 存储引擎是使用 B+ 树来组织数据的。B+ 树中的每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页在物理上可能不是相邻的，可能离的很远，那么磁盘查询时，就会有大量的随机 I/O, 而随机 I/O 是非常慢的。

要解决这个问题也很简单，就是把逻辑上相邻的两个数据页在物理上也相邻即可，那这样就可以使用顺序 I/O ，从而提高 I/O 性能。

在表中数据量大的时候，为某个索引分配空间的时候，就不再以页为基本分配单位，而是以区(extent) 为基本分配单位。

每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 页会被划分为一个区，这样就使得链表中逻辑相邻的页在物理上也相邻。

### 段(segment)

表空间是由各个段组成的，段是由多个区组成的。段一般分为数据段，索引段，回滚段等。

- 索引段: 存放 B+ 树的非叶子结点的区的集合
- 数据段: 存放 B+ 树叶子结点的区的结合
- 回滚段: 存放的是回滚数据的区的结合，MVCC 利用了回滚段实现了多版本数据查询


## InnoDB 行格式

行格式就是一条记录的存储结构。InnoDB 一共提供了 4 种行格式:

- Redundant: MySQL 5.0 版本之前用的行格式，现在基本没人用了
- Compact: 是一种紧凑的行格式，目的是为了让一个数据页存放更多的行，MySQL 5.0 之后，行格式默认为 Compact
- Dynamic: 是一种紧凑的行格式，基于 Compact 格式改进一点东西，MySQL 5.7 之后，默认使用 Dynamic 行格式
- Compressed: 是一种紧凑的行格式，基于 Compact 格式改进一点东西

Compact 与 Dynamic 和 Compressed 在对待行溢出上有区别：

- Compact 会保存一部分真实数据，然后用 20 个字节保存溢出页的地址
- Dynamic 和 Compressed 则不会在数据行中保存数据，只会保存 20 个字节的溢出页地址，溢出页中保存的全部的数据

### Compact 行格式

![](../Attachment/Pasted%20image%2020230203142027.png)

数据页中一行数据分为两个部分：

- 记录的额外信息
- 记录的真实数据

#### 记录的额外信息

记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。

##### 变长字段长度列表

varchar 和 char 的区别是：varchar 的长度不是固定的，而 char 的长度是固定的。

存储引擎在存储变长字段的数据时，会把变长字段的长度保存到 **变长字段长度列表** 里面; 读取变长字段的数据时，会根据变长字段长度列表中对应字段的长度读取数据，其他 TEXT、BLOB 等变长字段都是这么实现的。

首先创建一张表

```sql
create table t_user  
(  
    id    int         not null,  
    name  varchar(20) not null,  
    phone varchar(20) default null,  
    age   int(11)     default null,  
    primary key (id) using btree  
) engine = innodb  
  default charset = ascii  
  row_format = compact;
```

表的数据如下：

```text
+--+----+-----+----+  
|id|name|phone|age |  
+--+----+-----+----+  
|1 |a   |123  |18  |  
|2 |bb  |1234 |NULL|  
|3 |ccc |NULL |NULL|  
+--+----+-----+----+
```

先来看第一条记录：

- name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；
- phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；
- age 列和 id 列不是变长字段，所以这里不用管。

这些变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**, 所以「变长字段长度列表」里的内容是「03 01」，而不是 「01 03」

![](../Attachment/Pasted%20image%2020230203145055.png)

**第二条记录**的行格式中，「变长字段长度列表」里的内容是「 04 02」, 如下图:

![](../Attachment/Pasted%20image%2020230203145142.png)

**第三条记录**中 phone 列的值是 NULL，**NULL 是不会存放在行格式中记录的真实数据部分里的**，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。

![](../Attachment/Pasted%20image%2020230203145202.png)

###### 为什么变长字段列表的信息要逆序排放

主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。

「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。

同样的道理， NULL 值列表的信息也需要逆序存放

###### 变长字段列表示必须的吗？

其实变长字段字节数列表不是必须的。

**当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了**，因为没必要，不如去掉以节省空间。

所以「变长字段长度列表」只出现在数据表有变长字段的时候。

##### NULL 值列表

表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL 值列表中。

如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。

- 二进制位的值为 `1` 时，代表该列的值为 NULL。
- 二进制位的值为 `0` 时，代表该列的值不为 NULL。

另外，NULL 值列表必须用整数个字节的位表示（1 字节 8 位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`。

###### NULL 值列表是否是必须的

NULL 值列表也不是必须的。

**当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**

##### 记录头信息

记录头的信息很多，这里列举几个比较重要的：

- delete_mask：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0 表示普通记录，1 表示B+ 树非叶子节点记录，2 表示最小记录，3 表示最大记录

#### 记录的真实数据

记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer

![](../Attachment/Pasted%20image%2020230203152548.png)

- row_id: 如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。
- trx_id: 事务id，表示这个数据是由哪个事务生成的。 trx_id 是必需的，占用 6 个字节。
- roll_pointer: 回滚指针，记录该条记录上一个版本的数据所在的位置。roll_pointer 是必需的，占用 7 个字节

## MySQL 行大小

**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的**

也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。

对于变长字段来说，它的数据是由三个部分组成的：

- 真实数据
- 真实数据占用的字节数
- NULL 标识，如果不允许 NULL， 则不需要这部分

# 参考文章

- https://juejin.cn/post/7172057527813668900